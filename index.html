<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>åç‚¹æ£€æµ‹ä¸Šä½æœº</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#165DFF',
            secondary: '#36CFC9',
            accent: '#FF7D00',
            dark: '#1D2129',
            light: '#F2F3F5'
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          }
        }
      }
    }
  </script>
  <style type="text/tailwindcss">
    @layer utilities {
      .btn-view-active {
        @apply bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded transition-all duration-200 flex items-center justify-center gap-2;
      }
      .content-auto { content-visibility: auto; }
      .canvas-container {
        @apply relative border border-gray-300 rounded-lg overflow-hidden bg-gray-100;
      }
      .control-panel {
        @apply bg-white p-4 rounded-lg shadow-md;
      }
      .btn-primary {
        @apply bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded transition-all duration-200 flex items-center justify-center gap-2;
      }
      .btn-secondary {
        @apply bg-white border border-gray-300 hover:bg-gray-100 px-4 py-2 rounded transition-all duration-200 flex items-center justify-center gap-2;
      }
      .btn-accent {
        @apply bg-accent hover:bg-accent/90 text-white px-4 py-2 rounded transition-all duration-200 flex items-center justify-center gap-2;
      }
      .status-bar {
        @apply bg-light p-2 rounded text-sm border border-gray-200;
      }
      .debug-panel {
        @apply bg-dark text-white p-3 rounded-lg text-sm font-mono overflow-auto max-h-80;
      }
      .res-btn {
        @apply px-2 py-1 rounded text-xs border transition-all;
      }
      .res-btn.active {
        @apply bg-primary text-white border-primary;
      }
      .res-btn:not(.active) {
        @apply hover:bg-gray-100;
      }
      .drop-hover {
        @apply ring-4 ring-primary/50 bg-primary/10;
      }
    }
  </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
  <div class="container mx-auto px-4 py-6 max-w-7xl">
    <!-- æ ‡é¢˜åŒºåŸŸ -->
    <header class="mb-6">
      <h1 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-dark flex items-center gap-3">
        <i class="fa fa-search-plus text-primary"></i> åç‚¹æ£€æµ‹ä¸Šä½æœº
      </h1>
      <p class="text-gray-500 mt-1">åƒç´ çº§æ¸…æ™°æ˜¾ç¤º Â· å…¨èŒƒå›´å¯¹æ¯”åº¦æ‹‰ä¼¸ Â· åç‚¹ç²¾å‡†æ£€æµ‹ Â· v4.3 ä¿®å¤ç‰ˆ</p>
    </header>

    <!-- ä¸»å†…å®¹åŒºåŸŸ -->
    <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
      <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
      <div class="lg:col-span-1 space-y-4">
        <!-- æ–‡ä»¶æ“ä½œ -->
        <div class="control-panel">
          <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">æ–‡ä»¶æ“ä½œ</h2>
          <div class="space-y-3">
            <label class="btn-primary w-full cursor-pointer">
              <i class="fa fa-file-image-o"></i> åŠ è½½RAWæ–‡ä»¶
              <input type="file" id="fileInput" accept=".raw,.bin,.dat" class="hidden">
            </label>

            <!-- åˆ†è¾¨ç‡è®¾ç½®ï¼šé¡µé¢æ‰“å¼€å³æ˜¾ç¤º -->
            <div id="resolutionSettings" class="text-sm text-gray-500">
              <p class="font-medium text-dark mb-2">å›¾åƒåˆ†è¾¨ç‡ï¼ˆåŠ è½½æ—¶è‡ªåŠ¨åº”ç”¨ï¼‰</p>
              <div class="grid grid-cols-2 gap-2 mb-2">
                <div>
                  <label class="block text-xs text-gray-500">å®½åº¦</label>
                  <input type="number" id="widthInput" class="w-full text-sm border rounded px-2 py-1" value="640" min="1" max="4096">
                </div>
                <div>
                  <label class="block text-xs text-gray-500">é«˜åº¦</label>
                  <input type="number" id="heightInput" class="w-full text-sm border rounded px-2 py-1" value="512" min="1" max="4096">
                </div>
              </div>

              <!-- å¿«é€Ÿåˆ‡æ¢åˆ†è¾¨ç‡æŒ‰é’®ç»„ -->
              <div class="flex gap-2 mt-2 flex-wrap">
                <button class="res-btn active" data-width="640" data-height="512">640Ã—512</button>
                <button class="res-btn" data-width="384" data-height="288">384Ã—288</button>
                <button class="res-btn" data-width="1280" data-height="1024">1280Ã—1024</button>
              </div>

              <div class="space-y-2 mt-4">
                <div class="flex items-center gap-2 p-2 bg-gray-50 rounded border border-gray-200">
                  <input type="checkbox" id="rowMajorOrder" checked>
                  <label for="rowMajorOrder" class="text-sm">è¡Œä¼˜å…ˆå­˜å‚¨</label>
                </div>
                <div class="flex items-center gap-2 p-2 bg-gray-50 rounded border border-gray-200">
                  <input type="checkbox" id="littleEndian">
                  <label for="littleEndian" class="text-sm">å°ç«¯å­—èŠ‚åº</label>
                  <span class="text-[10px] text-gray-400">(é»˜è®¤å¤§ç«¯)</span>
                </div>
              </div>
            </div>

            <button id="autoAdjustButton" class="btn-secondary w-full mt-3" disabled>
              <i class="fa fa-adjust"></i> è‡ªåŠ¨äº®åº¦/å¯¹æ¯”åº¦
            </button>
            <button id="saveButton" class="btn-accent w-full" disabled>
              <i class="fa fa-save"></i> ä¿å­˜åç‚¹æ©ç 
            </button>
          </div>
        </div>

        <!-- æ‰‹åŠ¨æ ‡è®° -->
        <div class="control-panel">
          <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">æ‰‹åŠ¨æ ‡è®°</h2>
          <div class="space-y-3">
            <button id="startMarkingButton" class="btn-secondary w-full" disabled>
              <i class="fa fa-mouse-pointer"></i> å¼€å§‹æ‰‹åŠ¨æ ‡è®°
            </button>
            <button id="clearManualButton" class="btn-secondary w-full" disabled>
              <i class="fa fa-eraser"></i> æ¸…é™¤æ‰‹åŠ¨æ ‡è®°
            </button>
          </div>
        </div>

        <!-- æ£€æµ‹å‚æ•° -->
        <div class="control-panel">
          <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">æ£€æµ‹å‚æ•°</h2>
          <div class="space-y-4">
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">å·®å¼‚é˜ˆå€¼</label>
              <div class="flex items-center gap-2">
                <input type="range" id="thresholdSlider" min="10" max="200" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="thresholdValue" class="text-sm font-medium min-w-[40px] text-center">50</span>
              </div>
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">é‚»åŸŸå¤§å°</label>
              <select id="neighborhoodSelect" class="w-full text-sm border rounded px-2 py-1">
                <option value="3">3Ã—3</option>
                <option value="5" selected>5Ã—5</option>
                <option value="7">7Ã—7</option>
              </select>
            </div>
            <button id="detectButton" class="btn-primary w-full" disabled>
              <i class="fa fa-magic"></i> è‡ªåŠ¨æ£€æµ‹åç‚¹
            </button>
          </div>
        </div>

        <!-- å›¾åƒä¼˜åŒ– -->
        <div class="control-panel">
          <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">å›¾åƒä¼˜åŒ–</h2>
          <div class="space-y-4">
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">äº®åº¦</label>
              <div class="flex items-center gap-2">
                <input type="range" id="brightnessSlider" min=-100 max=100 value=0 class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="brightnessValue" class="text-sm font-medium min-w-[40px] text-center">0</span>
              </div>
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">å¯¹æ¯”åº¦</label>
              <div class="flex items-center gap-2">
                <input type="range" id="contrastSlider" min=50 max=200 value=100 class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="contrastValue" class="text-sm font-medium min-w-[40px] text-center">100%</span>
              </div>
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">ä¼½é©¬æ ¡æ­£</label>
              <div class="flex items-center gap-2">
                <input type="range" id="gammaSlider" min=0.1 max=3.0 step=0.1 value=1.0 class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="gammaValue" class="text-sm font-medium min-w-[40px] text-center">1.0</span>
              </div>
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">æ˜¾ç¤ºèŒƒå›´</label>
              <div class="grid grid-cols-2 gap-2">
                <div>
                  <label class="block text-xs text-gray-500">æœ€å°å€¼</label>
                  <input type="number" id="minRangeInput" class="w-full text-sm border rounded px-2 py-1" value="0" min="0" max="65535">
                </div>
                <div>
                  <label class="block text-xs text-gray-500">æœ€å¤§å€¼</label>
                  <input type="number" id="maxRangeInput" class="w-full text-sm border rounded px-2 py-1" value="65535" min="1" max="65535">
                </div>
              </div>
            </div>
            <button id="resetEnhanceButton" class="btn-secondary w-full text-xs py-1">
              <i class="fa fa-refresh"></i> é‡ç½®å‚æ•°
            </button>
          </div>
        </div>
      </div>

      <!-- å³ä¾§å›¾åƒæ˜¾ç¤ºå’ŒçŠ¶æ€ -->
      <div class="lg:col-span-3 space-y-4">
        <!-- è§†å›¾æ§åˆ¶ -->
        <div class="control-panel">
          <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">è§†å›¾æ§åˆ¶</h2>
          <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
            <button id="fitButton" class="btn-secondary">æ‹Ÿåˆå±å¹•</button>
            <button id="actualButton" class="btn-secondary">1:1 è§†å›¾</button>
            <button id="zoomInButton" class="btn-secondary"><i class="fa fa-search-plus"></i> æ”¾å¤§</button>
            <button id="zoomOutButton" class="btn-secondary"><i class="fa fa-search-minus"></i> ç¼©å°</button>
          </div>
        </div>

        <!-- å›¾åƒæ˜¾ç¤ºåŒºåŸŸ -->
        <div class="canvas-container" id="canvasContainer" style="height: 600px;">
          <canvas id="imageCanvas" class="w-full h-full"></canvas>
          <div id="loadingIndicator" class="absolute inset-0 bg-black/50 flex items-center justify-center hidden">
            <div class="bg-white p-4 rounded-lg flex items-center gap-3">
              <i class="fa fa-circle-o-notch fa-spin text-primary text-xl"></i>
              <span>å¤„ç†ä¸­...</span>
            </div>
          </div>
          <div id="noImageHint" class="absolute inset-0 flex flex-col items-center justify-center text-gray-400">
            <i class="fa fa-picture-o text-5xl mb-3"></i>
            <p class="text-lg">è¯·åŠ è½½RAWå›¾åƒæ–‡ä»¶</p>
            <p class="text-sm mt-2">æˆ–å°†æ–‡ä»¶æ‹–æ‹½åˆ°æ­¤å¤„</p>
          </div>
          <div class="mode-indicator view-mode absolute top-2 left-2 bg-black/70 text-white px-3 py-1 rounded text-sm hidden" id="viewModeIndicator">æŸ¥çœ‹æ¨¡å¼ï¼ˆæ»šè½®ç¼©æ”¾Â·æ‹–æ‹½å¹³ç§»ï¼‰</div>
          <div class="mode-indicator mark-mode absolute top-2 left-2 bg-red-500/70 text-white px-3 py-1 rounded text-sm hidden" id="markModeIndicator">æ ‡è®°æ¨¡å¼ï¼šæ–¹å‘é”®ç§»åŠ¨ï¼Œç©ºæ ¼æ ‡è®°ï¼Œå›è½¦é€€å‡º</div>
        </div>

        <!-- çŠ¶æ€å’Œä¿¡æ¯ -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div class="status-bar">
            <p><span class="font-medium">åç‚¹ç»Ÿè®¡:</span> è‡ªåŠ¨ <span id="autoBadCount" class="text-red-500">0</span> ä¸ªï¼Œæ‰‹åŠ¨ <span id="manualBadCount" class="text-blue-500">0</span> ä¸ªï¼Œæ€»è®¡ <span id="totalBadCount" class="text-accent">0</span> ä¸ª <span class="text-gray-500">( <span id="badPercentage">0.0000</span>% )</span></p>
          </div>
          <div class="status-bar">
            <p><span class="font-medium">å½“å‰åƒç´ :</span> X: <span id="currentX">-</span>, Y: <span id="currentY">-</span>, å€¼: <span id="currentValue">-</span></p>
          </div>
        </div>

        <!-- è°ƒè¯•é¢æ¿ -->
        <div class="debug-panel" id="debugPanel">
          <p class="font-medium mb-1">å›¾åƒç»Ÿè®¡ (ç­‰å¾…åŠ è½½):</p>
          <p>æœ€å°å€¼: -, æœ€å¤§å€¼: -, 1%åˆ†ä½: -, 99%åˆ†ä½: -</p>
        </div>

        <!-- åç‚¹åˆ—è¡¨é¢æ¿ -->
        <div class="debug-panel overflow-auto max-h-96" id="badPointListPanel">
          <p class="font-medium mb-1 text-green-400">ğŸ“Œ åç‚¹åˆ—è¡¨ï¼š</p>
          <p class="text-gray-300">æš‚æ— åç‚¹æ•°æ®ï¼Œè¯·åŠ è½½å›¾åƒå¹¶æ£€æµ‹/æ ‡è®°</p>
        </div>
      </div>
    </div>

    <!-- é¡µè„š -->
    <footer class="mt-8 text-center text-gray-500 text-sm py-4 border-t">
      <p>åç‚¹æ£€æµ‹ä¸Šä½æœº &copy; 2025_v4.1 ã€åˆ†è¾¨ç‡é¢„å…ˆè®¾ç½® Â· æ‹–æ‹½åŠ è½½ Â· è§†å›¾æ§åˆ¶ Â· åç‚¹ç‚¹å‡»è·³è½¬ Â· BUGä¿®å¤ç‰ˆã€‘</p>
    </footer>
  </div>

  <script>
    // å…¨å±€å˜é‡
    let imageData = null;
    let originalData = null;
    let width = 640;
    let height = 512;
    let autoBadPoints = new Set();
    let manualBadPoints = new Set();
    let isMarkingMode = false;
    let currentX = 0;
    let currentY = 0;
    let threshold = 50;
    let rowMajorOrder = true;
    let littleEndian = false;
    let imageStats = { min: 0, max: 0, p1: 0, p99: 0 };

    // å›¾åƒä¼˜åŒ–å‚æ•°
    let brightness = 0;
    let contrast = 100;
    let gamma = 1.0;
    let displayMin = 0;
    let displayMax = 65535;

    // ç”»å¸ƒç›¸å…³å˜é‡
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let lastX, lastY;
    let imageBitmap = null;

    // DOMå…ƒç´ 
    const fileInput = document.getElementById('fileInput');
    const widthInput = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');
    const rowMajorOrderCheckbox = document.getElementById('rowMajorOrder');
    const littleEndianCheckbox = document.getElementById('littleEndian');
    const noImageHint = document.getElementById('noImageHint');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const detectButton = document.getElementById('detectButton');
    const saveButton = document.getElementById('saveButton');
    const startMarkingButton = document.getElementById('startMarkingButton');
    const clearManualButton = document.getElementById('clearManualButton');
    const thresholdSlider = document.getElementById('thresholdSlider');
    const thresholdValue = document.getElementById('thresholdValue');
    const autoBadCount = document.getElementById('autoBadCount');
    const manualBadCount = document.getElementById('manualBadCount');
    const totalBadCount = document.getElementById('totalBadCount');
    const badPercentage = document.getElementById('badPercentage');
    const currentXEl = document.getElementById('currentX');
    const currentYEl = document.getElementById('currentY');
    const currentValueEl = document.getElementById('currentValue');
    const neighborhoodSelect = document.getElementById('neighborhoodSelect');
    const autoAdjustButton = document.getElementById('autoAdjustButton');
    const minRangeInput = document.getElementById('minRangeInput');
    const maxRangeInput = document.getElementById('maxRangeInput');
    const brightnessSlider = document.getElementById('brightnessSlider');
    const brightnessValue = document.getElementById('brightnessValue');
    const contrastSlider = document.getElementById('contrastSlider');
    const contrastValue = document.getElementById('contrastValue');
    const gammaSlider = document.getElementById('gammaSlider');
    const gammaValue = document.getElementById('gammaValue');
    const resetEnhanceButton = document.getElementById('resetEnhanceButton');
    const viewModeIndicator = document.getElementById('viewModeIndicator');
    const markModeIndicator = document.getElementById('markModeIndicator');
    const debugPanel = document.getElementById('debugPanel');
    const badPointListPanel = document.getElementById('badPointListPanel');
    const canvasContainer = document.getElementById('canvasContainer');
    const fitButton = document.getElementById('fitButton');
    const actualButton = document.getElementById('actualButton');
    const zoomInButton = document.getElementById('zoomInButton');
    const zoomOutButton = document.getElementById('zoomOutButton');

    // åˆå§‹åŒ–
    function init() {
      // é»˜è®¤ä½¿ç”¨è¾“å…¥æ¡†çš„å€¼è®¾ç½®å…¨å±€ width/height
      width = parseInt(widthInput.value);
      height = parseInt(heightInput.value);

      resizeCanvas();
      setupEventListeners();
      bindResolutionButtons();
      setupDragAndDrop();
      setActiveViewButton(fitButton); // åˆå§‹æ¿€æ´»æ‹Ÿåˆå±å¹•
    }

    // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
    function setupEventListeners() {
    window.addEventListener('resize', resizeCanvas);

      const viewButtons = [
      document.getElementById('fitButton'),
      document.getElementById('actualButton'),
      document.getElementById('zoomInButton'),
      document.getElementById('zoomOutButton')
    ];
    // è§†å›¾æŒ‰é’®æ¿€æ´»çŠ¶æ€åˆ‡æ¢å‡½æ•°
    function setActiveViewButton(activeBtn) {
      // éå†æ‰€æœ‰è§†å›¾æŒ‰é’®ï¼Œç§»é™¤æ¿€æ´»ç±»ã€æ¢å¤é»˜è®¤ç±»
      viewButtons.forEach(btn => {
        if (btn) { // é˜²æ­¢å…ƒç´ ä¸å­˜åœ¨çš„æŠ¥é”™
          btn.classList.remove('btn-view-active'); // ç§»é™¤æ¿€æ´»æ ·å¼
          btn.classList.add('btn-secondary'); // æ¢å¤é»˜è®¤æ ·å¼
        }
      });
      // ç»™å½“å‰ç‚¹å‡»çš„æŒ‰é’®æ·»åŠ æ¿€æ´»ç±»ã€ç§»é™¤é»˜è®¤ç±»
      if (activeBtn) {
        activeBtn.classList.remove('btn-secondary');
        activeBtn.classList.add('btn-view-active');
      }
    }


      thresholdSlider.addEventListener('input', (e) => {
        threshold = parseInt(e.target.value);
        thresholdValue.textContent = threshold;
      });

      brightnessSlider.addEventListener('input', (e) => {
        brightness = parseInt(e.target.value);
        brightnessValue.textContent = brightness;
        if (imageData) updateImage();
      });

      contrastSlider.addEventListener('input', (e) => {
        contrast = parseInt(e.target.value);
        contrastValue.textContent = `${contrast}%`;
        if (imageData) updateImage();
      });

      gammaSlider.addEventListener('input', (e) => {
        gamma = parseFloat(e.target.value);
        gammaValue.textContent = gamma.toFixed(1);
        if (imageData) updateImage();
      });

      minRangeInput.addEventListener('change', (e) => {
        displayMin = parseInt(e.target.value);
        if (imageData) updateImage();
      });

      maxRangeInput.addEventListener('change', (e) => {
        displayMax = parseInt(e.target.value);
        if (imageData) updateImage();
      });

      resetEnhanceButton.addEventListener('click', resetEnhanceParams);
      autoAdjustButton.addEventListener('click', autoAdjustImage);

      rowMajorOrderCheckbox.addEventListener('change', (e) => {
        rowMajorOrder = e.target.checked;
        if (originalData) reloadImageData();
      });

      littleEndianCheckbox.addEventListener('change', (e) => {
        littleEndian = e.target.checked;
        if (originalData) reloadImageData();
      });

      // è¾“å…¥æ¡†æ‰‹åŠ¨æ”¹å˜æ—¶æ›´æ–°å…¨å±€å˜é‡ï¼ˆå¦‚æœå·²æœ‰å›¾åƒåˆ™é‡æ–°åŠ è½½ï¼‰
      widthInput.addEventListener('change', () => {
        const newW = parseInt(widthInput.value);
        if (newW > 0 && newW <= 4096) {
          width = newW;
          syncResButtonActive();
          if (originalData) reloadImageData();
        }
      });

      heightInput.addEventListener('change', () => {
        const newH = parseInt(heightInput.value);
        if (newH > 0 && newH <= 4096) {
          height = newH;
          syncResButtonActive();
          if (originalData) reloadImageData();
        }
      });

      fileInput.addEventListener('change', handleFileSelect);
      detectButton.addEventListener('click', detectBadPoints);
      startMarkingButton.addEventListener('click', toggleMarkingMode);
      clearManualButton.addEventListener('click', clearManualMarkings);
      saveButton.addEventListener('click', saveResults);

      fitButton.addEventListener('click', () => {
        resetView(); // åŸæœ‰åŠŸèƒ½ä¿ç•™
        setActiveViewButton(fitButton); // æ–°å¢ï¼šæ¿€æ´»å½“å‰æŒ‰é’®
      });
      actualButton.addEventListener('click', () => {
        scale = 1;
        offsetX = (canvas.width - width * scale) / 2;
        offsetY = (canvas.height - height * scale) / 2;
        drawCanvas(); // åŸæœ‰åŠŸèƒ½ä¿ç•™
        setActiveViewButton(actualButton); // æ–°å¢ï¼šæ¿€æ´»å½“å‰æŒ‰é’®
      });
      // æ”¾å¤§ - ç»‘å®šæ¿€æ´»é€»è¾‘
      zoomInButton.addEventListener('click', () => {
        zoomView(1.5); // åŸæœ‰åŠŸèƒ½ä¿ç•™
        setActiveViewButton(zoomInButton); // æ–°å¢ï¼šæ¿€æ´»å½“å‰æŒ‰é’®
      });

      // ç¼©å° - ç»‘å®šæ¿€æ´»é€»è¾‘
      zoomOutButton.addEventListener('click', () => {
        zoomView(1 / 1.5); // åŸæœ‰åŠŸèƒ½ä¿ç•™
        setActiveViewButton(zoomOutButton); // æ–°å¢ï¼šæ¿€æ´»å½“å‰æŒ‰é’®
      });

      setupCanvasEvents();
    }

    // æ‹–æ‹½åŠ è½½æ”¯æŒ
    function setupDragAndDrop() {
      canvasContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        canvasContainer.classList.add('drop-hover');
      });
      canvasContainer.addEventListener('dragleave', () => {
        canvasContainer.classList.remove('drop-hover');
      });
      canvasContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        canvasContainer.classList.remove('drop-hover');
        const file = e.dataTransfer.files[0];
        if (file && /\.(raw|bin|dat)$/i.test(file.name)) {
          const dt = new DataTransfer();
          dt.items.add(file);
          fileInput.files = dt.files;
          handleFileSelect({ target: { files: dt.files } });
        }
      });
    }

    // è§†å›¾ç¼©æ”¾ï¼ˆä¿æŒä¸­å¿ƒï¼‰
    function zoomView(factor) {
      const prevScale = scale;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const imgX = (centerX - offsetX) / prevScale;
      const imgY = (centerY - offsetY) / prevScale;

      scale *= factor;
      scale = Math.max(0.1, Math.min(20, scale));

      offsetX = centerX - imgX * scale;
      offsetY = centerY - imgY * scale;
      drawCanvas();
    }

    // ç‚¹å‡»åç‚¹è·³è½¬å¹¶æ”¾å¤§
    function centerOnPoint(x, y) {
      scale = 8;
      offsetX = canvas.width / 2 - (x + 0.5) * scale;
      offsetY = canvas.height / 2 - (y + 0.5) * scale;
      drawCanvas();
    }

    // âœ… ä¿®å¤BUG1ï¼šåˆ†è¾¨ç‡æŒ‰é’®ç»‘å®šäº‹ä»¶ã€æ ¸å¿ƒä¿®å¤ã€‘- å¢å¼ºé€‰ä¸­é€»è¾‘+å¼ºåˆ¶ç”Ÿæ•ˆ
    function bindResolutionButtons() {
      const resBtns = document.querySelectorAll('.res-btn');
      resBtns.forEach(btn => {
        btn.onclick = function() {
          const newW = parseInt(this.dataset.width);
          const newH = parseInt(this.dataset.height);
          // å¼ºåˆ¶èµ‹å€¼è¾“å…¥æ¡†+å…¨å±€å˜é‡
          widthInput.value = newW;
          heightInput.value = newH;
          width = newW;
          height = newH;
          // æ¸…ç©ºæ‰€æœ‰æŒ‰é’®çš„é€‰ä¸­çŠ¶æ€ï¼Œåªé«˜äº®å½“å‰ç‚¹å‡»çš„
          resBtns.forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          // æœ‰å›¾åƒåˆ™é‡æ–°åŠ è½½
          if (originalData) reloadImageData();
        }
      });
    }
    // âœ… æ–°å¢ï¼šè¾“å…¥æ¡†ä¿®æ”¹åˆ†è¾¨ç‡åï¼ŒåŒæ­¥æŒ‰é’®é€‰ä¸­çŠ¶æ€
    function syncResButtonActive(){
        const resBtns = document.querySelectorAll('.res-btn');
        resBtns.forEach(btn => {
            const btnW = parseInt(btn.dataset.width);
            const btnH = parseInt(btn.dataset.height);
            if(btnW === width && btnH === height){
                resBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            }
        });
    }

    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      if (imageBitmap) drawCanvas();
    }

    function setupCanvasEvents() {
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('wheel', handleMouseWheel);
      window.addEventListener('keydown', handleKeyDown);
    }

    function resetEnhanceParams() {
      brightness = 0; contrast = 100; gamma = 1.0; displayMin = 0; displayMax = 65535;
      brightnessSlider.value = brightness; brightnessValue.textContent = brightness;
      contrastSlider.value = contrast; contrastValue.textContent = `${contrast}%`;
      gammaSlider.value = gamma; gammaValue.textContent = gamma.toFixed(1);
      minRangeInput.value = displayMin; maxRangeInput.value = displayMax;
      if (imageData) updateImage();
    }

    function autoAdjustImage() {
      if (!imageData) return;
      displayMin = imageStats.p1;
      displayMax = imageStats.p99;
      minRangeInput.value = displayMin;
      maxRangeInput.value = displayMax;
      updateImage();
    }

    function reloadImageData() {
      if (!originalData) return;
      showLoading();
      try {
        const totalPixels = width * height;
        imageData = convertEndianness(originalData, totalPixels);
        calculateImageStats();
        updateImage();
        resetView();
        hideLoading();
      } catch (error) {
        console.error('é‡æ–°åŠ è½½å›¾åƒå¤±è´¥:', error);
        hideLoading();
      }
    }

    function convertEndianness(byteData, totalPixels) {
      const result = new Uint16Array(totalPixels);
      const byteView = new Uint8Array(byteData);
      const needBytes = totalPixels * 2;
      if (byteView.length < needBytes) {
        throw new Error(`æ•°æ®ä¸è¶³ï¼šéœ€è¦ ${needBytes} å­—èŠ‚ï¼Œä½†åªæä¾›äº† ${byteView.length} å­—èŠ‚`);
      }
      for (let i = 0; i < totalPixels; i++) {
        const byteOffset = i * 2;
        if (littleEndian) {
          result[i] = (byteView[byteOffset + 1] << 8) | byteView[byteOffset];
        } else {
          result[i] = (byteView[byteOffset] << 8) | byteView[byteOffset + 1];
        }
      }
      return result;
    }

    async function handleFileSelect(e) {
      const file = e.target.files[0];
      if (!file) return;
      showLoading();

      // ç›´æ¥ä½¿ç”¨å½“å‰è¾“å…¥çš„åˆ†è¾¨ç‡
      width = parseInt(widthInput.value);
      height = parseInt(heightInput.value);

      try {
        const arrayBuffer = await readFileAsync(file);
        originalData = arrayBuffer;
        const totalPixels = width * height;
        imageData = convertEndianness(originalData, totalPixels);
        calculateImageStats();
        autoAdjustImage();
        autoBadPoints.clear();
        manualBadPoints.clear();
        updateBadCount();
        updateBadPointList();
        updateImage();
        resetView();

        detectButton.disabled = false;
        startMarkingButton.disabled = false;
        saveButton.disabled = false;
        clearManualButton.disabled = false;
        autoAdjustButton.disabled = false;
        noImageHint.classList.add('hidden');
        viewModeIndicator.classList.remove('hidden');
      } catch (error) {
        console.error('åŠ è½½æ–‡ä»¶å¤±è´¥:', error);
        alert('åŠ è½½æ–‡ä»¶å¤±è´¥: ' + error.message);
      } finally {
        hideLoading();
      }
    }

    function calculateImageStats() {
      if (!imageData) return;
      const sortedValues = new Uint16Array(imageData);
      sortedValues.sort();
      const minValue = sortedValues[0];
      const maxValue = sortedValues[sortedValues.length - 1];
      const p1 = sortedValues[Math.floor(sortedValues.length * 0.01)];
      const p99 = sortedValues[Math.floor(sortedValues.length * 0.99)];

      imageStats = { min: minValue, max: maxValue, p1: p1, p99: p99 };
      debugPanel.innerHTML = `
        <p class="font-medium mb-1">å›¾åƒç»Ÿè®¡ (${width}Ã—${height}):</p>
        <p>æœ€å°å€¼: ${minValue}, æœ€å¤§å€¼: ${maxValue}</p>
        <p>1%åˆ†ä½: ${p1}, 99%åˆ†ä½: ${p99}</p>
        <p class="text-xs text-gray-400">æç¤ºï¼šè‹¥æœ€å¤§å€¼<100ï¼Œå¯èƒ½å­—èŠ‚åº/å­˜å‚¨é¡ºåºé”™è¯¯</p>
      `;
    }

    async function updateImage() {
      if (!imageData) return;
      showLoading();
      try {
        await createImageBitmapFromData();
        drawCanvas();
        hideLoading();
      } catch (error) {
        console.error('æ›´æ–°å›¾åƒå¤±è´¥:', error);
        hideLoading();
      }
    }

    async function createImageBitmapFromData() {
      const rgbaData = new Uint8ClampedArray(width * height * 4);
      const contrastFactor = contrast / 100;
      const brightnessOffset = brightness * 2.55;
      const range = Math.max(1, displayMax - displayMin);

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const index = rowMajorOrder ? (y * width + x) : (x * height + y);
          let value = imageData[index];
          value = Math.max(displayMin, Math.min(displayMax, value));
          let normalized = (value - displayMin) / range;
          normalized = Math.pow(normalized, 1 / gamma);
          normalized = 0.5 + contrastFactor * (normalized - 0.5);
          normalized += brightnessOffset / 255;
          normalized = Math.max(0, Math.min(1, normalized));
          const byteValue = Math.floor(normalized * 255);
          const rgbaIndex = (y * width + x) * 4;
          rgbaData[rgbaIndex] = byteValue;
          rgbaData[rgbaIndex + 1] = byteValue;
          rgbaData[rgbaIndex + 2] = byteValue;
          rgbaData[rgbaIndex + 3] = 255;
        }
      }

      const imageDataObj = new ImageData(rgbaData, width, height);
      imageBitmap = await createImageBitmap(imageDataObj);
    }

    function drawCanvas() {
      if (!imageBitmap) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.scale(scale, scale);
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(imageBitmap, 0, 0);

      ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
      autoBadPoints.forEach(point => {
        const [y, x] = point.split(',').map(Number);
        ctx.beginPath();
        ctx.arc(x + 0.5, y + 0.5, 2 / scale, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.fillStyle = 'rgba(0, 204, 255, 1)';
      manualBadPoints.forEach(point => {
        const [y, x] = point.split(',').map(Number);
        ctx.beginPath();
        ctx.arc(x + 0.5, y + 0.5, 2 / scale, 0, Math.PI * 2);
        ctx.fill();
      });

      if (isMarkingMode) {
        ctx.strokeStyle = 'rgba(0, 255, 0, 1)';
        ctx.lineWidth = 1 / scale;
        ctx.beginPath();
        ctx.moveTo(currentX - 3 / scale + 0.5, currentY + 0.5);
        ctx.lineTo(currentX + 3 / scale + 0.5, currentY + 0.5);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(currentX + 0.5, currentY - 3 / scale + 0.5);
        ctx.lineTo(currentX + 0.5, currentY + 3 / scale + 0.5);
        ctx.stroke();
      }
      ctx.restore();
    }

    async function detectBadPoints() {
      if (!imageData) return;
      showLoading();
      detectButton.disabled = true;
      try {
        const neighborhoodSize = parseInt(neighborhoodSelect.value);
        const halfNeighborhood = Math.floor(neighborhoodSize / 2);
        const badPoints = new Set();

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const centerIndex = rowMajorOrder ? (y * width + x) : (x * height + y);
            const centerValue = imageData[centerIndex];
            let aboveThresholdCount = 0;
            let validNeighbors = 0;

            for (let ny = -halfNeighborhood; ny <= halfNeighborhood; ny++) {
              for (let nx = -halfNeighborhood; nx <= halfNeighborhood; nx++) {
                if (nx === 0 && ny === 0) continue;
                const neighborX = x + nx;
                const neighborY = y + ny;
                if (neighborX >= 0 && neighborX < width && neighborY >= 0 && neighborY < height) {
                  const neighborIndex = rowMajorOrder ? (neighborY * width + neighborX) : (neighborX * height + neighborY);
                  const neighborValue = imageData[neighborIndex];
                  if (Math.abs(centerValue - neighborValue) > threshold) {
                    aboveThresholdCount++;
                  }
                  validNeighbors++;
                }
              }
            }

            if (validNeighbors > 0 && aboveThresholdCount > validNeighbors / 2) {
              badPoints.add(`${y},${x}`);
            }
          }
        }

        autoBadPoints = badPoints;
        updateBadCount();
        updateBadPointList();
        drawCanvas();
      } catch (error) {
        console.error('æ£€æµ‹åç‚¹å¤±è´¥:', error);
        alert('æ£€æµ‹åç‚¹å¤±è´¥: ' + error.message);
      } finally {
        detectButton.disabled = false;
        hideLoading();
      }
    }

  function toggleMarkingMode() {
    if (!imageData) return;
    if (isMarkingMode) {
      // é€€å‡ºæ ‡è®°æ¨¡å¼ï¼šæ¢å¤æŒ‰é’®é»˜è®¤æ ·å¼ï¼ˆç°ç™½è¾¹æ¡†ï¼‰
      isMarkingMode = false;
      startMarkingButton.innerHTML = '<i class="fa fa-mouse-pointer"></i> å¼€å§‹æ‰‹åŠ¨æ ‡è®°';
      startMarkingButton.className = 'btn-secondary w-full'; // æ¢å¤é»˜è®¤çš„æŒ‰é’®æ ·å¼ç±»
      currentXEl.textContent = '-';
      currentYEl.textContent = '-';
      currentValueEl.textContent = '-';
      document.body.style.cursor = '';
      viewModeIndicator.classList.remove('hidden');
      markModeIndicator.classList.add('hidden');
    } else {
      // è¿›å…¥æ ‡è®°æ¨¡å¼ï¼šæ”¹æˆã€è“è‰²èƒŒæ™¯+ç™½è‰²æ–‡å­—ã€‘ä½ è¦çš„æ•ˆæœ âœ…æ ¸å¿ƒä¿®æ”¹
      isMarkingMode = true;
      startMarkingButton.innerHTML = '<i class="fa fa-stop"></i> é€€å‡ºæ‰‹åŠ¨æ ‡è®°';
      startMarkingButton.className = 'btn-primary w-full'; // ç›´æ¥ç”¨ä½ å®šä¹‰å¥½çš„è“è‰²ä¸»æŒ‰é’®æ ·å¼
      currentX = Math.floor(width / 2);
      currentY = Math.floor(height / 2);
      updateCurrentPositionInfo();
      document.body.style.cursor = 'crosshair';
      viewModeIndicator.classList.add('hidden');
      markModeIndicator.classList.remove('hidden');
    }
    drawCanvas();
  }

    function clearManualMarkings() {
      if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰æ‰‹åŠ¨æ ‡è®°çš„åç‚¹å—ï¼Ÿ')) {
        manualBadPoints.clear();
        updateBadCount();
        updateBadPointList();
        drawCanvas();
      }
    }

    function saveResults() {
      if (!imageData) return;
      showLoading();
      try {
        const totalPixels = width * height;
        const totalBytes = totalPixels * 2;
        const badFlagData = new Uint16Array(totalPixels);
        const allBadPoints = new Set([...autoBadPoints, ...manualBadPoints]);

        allBadPoints.forEach(point => {
          const [y, x] = point.split(',').map(Number);
          const index = rowMajorOrder ? (y * width + x) : (x * height + y);
          badFlagData[index] = 0x1000;
        });

        const byteData = new Uint8Array(totalBytes);
        for (let i = 0; i < totalPixels; i++) {
          const byteOffset = i * 2;
          const value = badFlagData[i];
          if (littleEndian) {
            byteData[byteOffset] = value & 0xFF;
            byteData[byteOffset + 1] = (value >> 8) & 0xFF;
          } else {
            byteData[byteOffset] = (value >> 8) & 0xFF;
            byteData[byteOffset + 1] = value & 0xFF;
          }
        }

        const blob = new Blob([byteData.buffer], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        let downloadName = 'bad_points.bin';
        if (fileInput.files[0]) {
          downloadName = fileInput.files[0].name.replace(/\.[^/.]+$/, "") + "_bad.bin";
        }
        a.href = url;
        a.download = downloadName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error('ä¿å­˜æ–‡ä»¶å¤±è´¥:', error);
        alert('ä¿å­˜æ–‡ä»¶å¤±è´¥: ' + error.message);
      } finally {
        hideLoading();
      }
    }

    function handleMouseDown(e) {
      if (!imageData) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const imgX = Math.floor((mouseX - offsetX) / scale);
      const imgY = Math.floor((mouseY - offsetY) / scale);

      if (isMarkingMode) {
        if (imgX >= 0 && imgX < width && imgY >= 0 && imgY < height) {
          currentX = imgX;
          currentY = imgY;
          updateCurrentPositionInfo();
          drawCanvas();
        }
      } else {
        isDragging = true;
        lastX = mouseX;
        lastY = mouseY;
        canvas.style.cursor = 'grabbing';
      }
    }

    function handleMouseMove(e) {
      if (!imageData) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      if (isDragging) {
        const dx = mouseX - lastX;
        const dy = mouseY - lastY;
        offsetX += dx;
        offsetY += dy;
        lastX = mouseX;
        lastY = mouseY;
        drawCanvas();
        return;
      }

      const x = Math.floor((mouseX - offsetX) / scale);
      const y = Math.floor((mouseY - offsetY) / scale);
      if (x >= 0 && x < width && y >= 0 && y < height) {
        const index = rowMajorOrder ? (y * width + x) : (x * height + y);
        const value = imageData[index];
        currentXEl.textContent = x;
        currentYEl.textContent = y;
        currentValueEl.textContent = value;
      } else {
        currentXEl.textContent = '-';
        currentYEl.textContent = '-';
        currentValueEl.textContent = '-';
      }
    }

    function handleMouseUp() {
      if (isDragging) {
        isDragging = false;
        canvas.style.cursor = 'grab';
      }
    }

    function handleMouseWheel(e) {
      if (!imageData) return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const imgX = (mouseX - offsetX) / scale;
      const imgY = (mouseY - offsetY) / scale;

      const zoomIntensity = 0.1;
      if (e.deltaY < 0) {
        scale *= (1 + zoomIntensity);
      } else {
        scale /= (1 + zoomIntensity);
      }
      scale = Math.min(Math.max(0.1, scale), 20);

      offsetX = mouseX - imgX * scale;
      offsetY = mouseY - imgY * scale;
      drawCanvas();
    }

    // âœ… ä¿®å¤BUG2ï¼šæ–¹å‘é”®æ»šåŠ¨ç½‘é¡µã€æ ¸å¿ƒä¿®å¤ã€‘- æ‰€æœ‰æ ‡è®°æ¨¡å¼æŒ‰é”®æ·»åŠ  e.preventDefault() é˜»æ­¢é»˜è®¤è¡Œä¸º
    function handleKeyDown(e) {
      if (!isMarkingMode || !imageData) return;
      let moved = false;
      switch (e.key) {
        case 'ArrowUp':
          e.preventDefault(); // é˜»æ­¢é¡µé¢ä¸Šæ»š
          if (currentY > 0) { currentY--; moved = true; }
          break;
        case 'ArrowDown':
          e.preventDefault(); // é˜»æ­¢é¡µé¢ä¸‹æ»š
          if (currentY < height - 1) { currentY++; moved = true; }
          break;
        case 'ArrowLeft':
          e.preventDefault(); // é˜»æ­¢é¡µé¢å·¦æ»š
          if (currentX > 0) { currentX--; moved = true; }
          break;
        case 'ArrowRight':
          e.preventDefault(); // é˜»æ­¢é¡µé¢å³æ»š
          if (currentX < width - 1) { currentX++; moved = true; }
          break;
        case ' ':
          e.preventDefault(); // é˜»æ­¢ç©ºæ ¼ç¿»é¡µ
          const point = `${currentY},${currentX}`;
          if (manualBadPoints.has(point)) {
            manualBadPoints.delete(point);
          } else {
            manualBadPoints.add(point);
          }
          updateBadCount();
          updateBadPointList();
          drawCanvas();
          break;
        case 'Enter':
          e.preventDefault(); // é˜»æ­¢å›è½¦é»˜è®¤è¡Œä¸º
          toggleMarkingMode();
          break;
      }
      if (moved) {
        updateCurrentPositionInfo();
        drawCanvas();
      }
    }

    function resetView() {
      const scaleX = canvas.width / width;
      const scaleY = canvas.height / height;
      scale = Math.min(scaleX, scaleY);
      offsetX = (canvas.width - width * scale) / 2;
      offsetY = (canvas.height - height * scale) / 2;
      drawCanvas();
    }

    function updateBadCount() {
      const autoCount = autoBadPoints.size;
      const manualCount = manualBadPoints.size;
      const totalCount = autoCount + manualCount;
      const totalPixels = width * height;
      const percentage = totalPixels > 0 ? (totalCount / totalPixels * 100).toFixed(6) : '0.0000';

      autoBadCount.textContent = autoCount;
      manualBadCount.textContent = manualCount;
      totalBadCount.textContent = totalCount;
      badPercentage.textContent = percentage;
    }

    function updateBadPointList() {
      const autoList = Array.from(autoBadPoints)
        .sort((a, b) => {
          const [ya, xa] = a.split(',').map(Number);
          const [yb, xb] = b.split(',').map(Number);
          return ya - yb || xa - xb;
        })
        .map(point => {
          const [y, x] = point.split(',').map(Number);
          return `<div class="cursor-pointer hover:bg-white/10 py-0.5" onclick="centerOnPoint(${x},${y})"><span class="text-red-400">(${x}, ${y})</span> <span class="text-red-300 text-xs">è‡ªåŠ¨</span></div>`;
        });

      const manualList = Array.from(manualBadPoints)
        .sort((a, b) => {
          const [ya, xa] = a.split(',').map(Number);
          const [yb, xb] = b.split(',').map(Number);
          return ya - yb || xa - xb;
        })
        .map(point => {
          const [y, x] = point.split(',').map(Number);
          return `<div class="cursor-pointer hover:bg-white/10 py-0.5" onclick="centerOnPoint(${x},${y})"><span class="text-blue-400">(${x}, ${y})</span> <span class="text-blue-300 text-xs">æ‰‹åŠ¨</span></div>`;
        });

      const allPoints = [...autoList, ...manualList];

      if (allPoints.length === 0) {
        badPointListPanel.innerHTML = `
          <p class="font-medium mb-1 text-green-400">ğŸ“Œ åç‚¹åˆ—è¡¨ï¼š</p>
          <p class="text-gray-300">æš‚æ— åç‚¹æ•°æ®ï¼Œè¯·åŠ è½½å›¾åƒå¹¶æ£€æµ‹/æ ‡è®°</p>
        `;
      } else {
        badPointListPanel.innerHTML = `
          <p class="font-medium mb-1 text-green-400">ğŸ“Œ åç‚¹åˆ—è¡¨ï¼ˆå…± ${allPoints.length} ä¸ªï¼Œç‚¹å‡»åæ ‡å¯è·³è½¬ï¼‰ï¼š</p>
          <div class="flex flex-col gap-1 mt-1">${allPoints.join('')}</div>
        `;
      }
    }

    function updateCurrentPositionInfo() {
      if (!imageData) return;
      currentXEl.textContent = currentX;
      currentYEl.textContent = currentY;
      const index = rowMajorOrder ? (currentY * width + currentX) : (currentX * height + currentY);
      currentValueEl.textContent = imageData[index];
    }

    function showLoading() {
      loadingIndicator.classList.remove('hidden');
    }

    function hideLoading() {
      loadingIndicator.classList.add('hidden');
    }

    function readFileAsync(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsArrayBuffer(file);
      });
    }

    init();
  </script>
</body>
</html>
