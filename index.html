<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åç‚¹æ£€æµ‹ä¸Šä½æœº</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#36CFC9',
                        accent: '#FF7D00',
                        dark: '#1D2129',
                        light: '#F2F3F5'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .canvas-container {
                @apply relative border border-gray-300 rounded-lg overflow-hidden bg-gray-100;
            }
            .control-panel {
                @apply bg-white p-4 rounded-lg shadow-md;
            }
            .btn-primary {
                @apply bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded transition-all duration-200 flex items-center justify-center gap-2;
            }
            .btn-secondary {
                @apply bg-white border border-gray-300 hover:bg-gray-100 px-4 py-2 rounded transition-all duration-200 flex items-center justify-center gap-2;
            }
            .btn-accent {
                @apply bg-accent hover:bg-accent/90 text-white px-4 py-2 rounded transition-all duration-200 flex items-center justify-center gap-2;
            }
            .status-bar {
                @apply bg-light p-2 rounded text-sm border border-gray-200;
            }
            .debug-panel {
                @apply bg-dark text-white p-3 rounded-lg text-sm font-mono overflow-auto max-h-80;
            }
            .res-btn {
                @apply px-2 py-1 rounded text-xs border transition-all;
            }
            .res-btn.active {
                @apply bg-primary text-white border-primary;
            }
            .res-btn:not(.active) {
                @apply hover:bg-gray-100;
            }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div class="container mx-auto px-4 py-6 max-w-7xl">
        <!-- æ ‡é¢˜åŒºåŸŸ -->
        <header class="mb-6">
            <h1 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-dark flex items-center gap-3">
                <i class="fa fa-search-plus text-primary"></i>
                åç‚¹æ£€æµ‹ä¸Šä½æœº
            </h1>
            <p class="text-gray-500 mt-1">åƒç´ çº§æ¸…æ™°æ˜¾ç¤º Â· å…¨èŒƒå›´å¯¹æ¯”åº¦æ‹‰ä¼¸ Â· åç‚¹ç²¾å‡†æ£€æµ‹</p>
        </header>

        <!-- ä¸»å†…å®¹åŒºåŸŸ -->
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
            <div class="lg:col-span-1 space-y-4">
                <!-- æ–‡ä»¶æ“ä½œ -->
                <div class="control-panel">
                    <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">æ–‡ä»¶æ“ä½œ</h2>
                    <div class="space-y-3">
                        <label class="btn-primary w-full cursor-pointer">
                            <i class="fa fa-file-image-o"></i> åŠ è½½RAWæ–‡ä»¶
                            <input type="file" id="fileInput" accept=".raw,.bin,.dat" class="hidden">
                        </label>
                        <div id="fileInfo" class="text-sm text-gray-500 hidden">
                            <p id="fileName" class="truncate"></p>
                            <div class="grid grid-cols-2 gap-2 mt-2">
                                <div>
                                    <label class="block text-xs text-gray-500">å®½åº¦</label>
                                    <input type="number" id="widthInput" class="w-full text-sm border rounded px-2 py-1" value="640" min="1" max="2048">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-500">é«˜åº¦</label>
                                    <input type="number" id="heightInput" class="w-full text-sm border rounded px-2 py-1" value="512" min="1" max="2048">
                                </div>
                            </div>
                            <!-- æ–°å¢ï¼šå¿«é€Ÿåˆ‡æ¢åˆ†è¾¨ç‡æŒ‰é’®ç»„ -->
                            <div class="flex gap-2 mt-2">
                                <button class="res-btn active" data-width="640" data-height="512">640Ã—512</button>
                                <button class="res-btn" data-width="384" data-height="288">384Ã—288</button>
                            </div>
                            <button id="applySizeButton" class="btn-secondary w-full mt-2 text-xs py-1">
                                åº”ç”¨å°ºå¯¸
                            </button>
                            <div class="space-y-2 mt-3">
                                <div class="flex items-center gap-2 p-2 bg-gray-50 rounded border border-gray-200">
                                    <input type="checkbox" id="rowMajorOrder" checked>
                                    <label for="rowMajorOrder" class="text-sm">è¡Œä¼˜å…ˆå­˜å‚¨</label>
                                </div>
                                <div class="flex items-center gap-2 p-2 bg-gray-50 rounded border border-gray-200">
                                    <input type="checkbox" id="littleEndian">
                                    <label for="littleEndian" class="text-sm">å°ç«¯å­—èŠ‚åº</label>
                                    <span class="text-[10px] text-gray-400">(é»˜è®¤å¤§ç«¯)</span>
                                </div>
                            </div>
                        </div>
                        <button id="autoAdjustButton" class="btn-secondary w-full" disabled>
                            <i class="fa fa-adjust"></i> è‡ªåŠ¨äº®åº¦/å¯¹æ¯”åº¦
                        </button>
                        <button id="saveButton" class="btn-accent w-full" disabled>
                            <i class="fa fa-save"></i> ä¿å­˜ç»“æœ
                        </button>
                    </div>
                </div>

                <!-- æ‰‹åŠ¨æ ‡è®° -->

                <div class="control-panel">
                    <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">æ‰‹åŠ¨æ ‡è®°</h2>
                    <div class="space-y-3">
                        <button id="startMarkingButton" class="btn-secondary w-full" disabled>
                            <i class="fa fa-mouse-pointer"></i> å¼€å§‹æ‰‹åŠ¨æ ‡è®°
                        </button>
                        <button id="clearManualButton" class="btn-secondary w-full" disabled>
                            <i class="fa fa-eraser"></i> æ¸…é™¤æ‰‹åŠ¨æ ‡è®°
                        </button>
                    </div>
                </div>

                <!-- æ£€æµ‹å‚æ•° -->
                <div class="control-panel">
                    <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">æ£€æµ‹å‚æ•°</h2>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">å·®å¼‚é˜ˆå€¼</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="thresholdSlider" min="10" max="200" value="50"
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                <span id="thresholdValue" class="text-sm font-medium min-w-[40px] text-center">50</span>
                            </div>
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">é‚»åŸŸå¤§å°</label>
                            <select id="neighborhoodSelect" class="w-full text-sm border rounded px-2 py-1">
                                <option value="3">3Ã—3</option>
                                <option value="5" selected>5Ã—5</option>
                                <option value="7">7Ã—7</option>
                            </select>
                        </div>

                        <button id="detectButton" class="btn-primary w-full" disabled>
                            <i class="fa fa-magic"></i> è‡ªåŠ¨æ£€æµ‹åç‚¹
                        </button>
                    </div>
                </div>

                <!-- å›¾åƒå¢å¼º -->
                <div class="control-panel">
                    <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">å›¾åƒä¼˜åŒ–</h2>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">äº®åº¦</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="brightnessSlider" min=-100 max=100 value=0
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                <span id="brightnessValue" class="text-sm font-medium min-w-[40px] text-center">0</span>
                            </div>
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">å¯¹æ¯”åº¦</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="contrastSlider" min=50 max=200 value=100
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                <span id="contrastValue" class="text-sm font-medium min-w-[40px] text-center">100%</span>
                            </div>
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">ä¼½é©¬æ ¡æ­£</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="gammaSlider" min=0.1 max=3.0 step=0.1 value=1.0
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                <span id="gammaValue" class="text-sm font-medium min-w-[40px] text-center">1.0</span>
                            </div>
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">æ˜¾ç¤ºèŒƒå›´</label>
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="block text-xs text-gray-500">æœ€å°å€¼</label>
                                    <input type="number" id="minRangeInput" class="w-full text-sm border rounded px-2 py-1" value="0" min="0" max="65535">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-500">æœ€å¤§å€¼</label>
                                    <input type="number" id="maxRangeInput" class="w-full text-sm border rounded px-2 py-1" value="4095" min="1" max="65535">
                                </div>
                            </div>
                        </div>

                        <button id="resetEnhanceButton" class="btn-secondary w-full text-xs py-1">
                            <i class="fa fa-refresh"></i> é‡ç½®å‚æ•°
                        </button>
                    </div>
                </div>

            </div>

            <!-- å³ä¾§å›¾åƒæ˜¾ç¤ºå’ŒçŠ¶æ€ -->
            <div class="lg:col-span-3 space-y-4">
                <!-- å›¾åƒæ˜¾ç¤ºåŒºåŸŸ -->
                <div class="canvas-container" style="height: 600px;">
                    <canvas id="imageCanvas" class="w-full h-full"></canvas>
                    <!-- åŠ è½½ä¸­æŒ‡ç¤ºå™¨ -->
                    <div id="loadingIndicator" class="absolute inset-0 bg-black/50 flex items-center justify-center hidden">
                        <div class="bg-white p-4 rounded-lg flex items-center gap-3">
                            <i class="fa fa-circle-o-notch fa-spin text-primary text-xl"></i>
                            <span>å¤„ç†ä¸­...</span>
                        </div>
                    </div>
                    <!-- æ— å›¾åƒæç¤º -->
                    <div id="noImageHint" class="absolute inset-0 flex flex-col items-center justify-center text-gray-400">
                        <i class="fa fa-picture-o text-5xl mb-3"></i>
                        <p>è¯·åŠ è½½RAWå›¾åƒæ–‡ä»¶</p>
                    </div>
                    <!-- æ¨¡å¼æŒ‡ç¤ºå™¨ -->
                    <div class="mode-indicator view-mode absolute top-2 left-2 bg-black/70 text-white px-3 py-1 rounded text-sm hidden" id="viewModeIndicator">
                        æŸ¥çœ‹æ¨¡å¼
                    </div>
                    <div class="mode-indicator mark-mode absolute top-2 left-2 bg-red-500/70 text-white px-3 py-1 rounded text-sm hidden" id="markModeIndicator">
                        æ ‡è®°æ¨¡å¼ï¼šæ–¹å‘é”®ç§»åŠ¨ï¼Œç©ºæ ¼æ ‡è®°ï¼Œå›è½¦é€€å‡º
                    </div>
                </div>

                <!-- çŠ¶æ€å’Œä¿¡æ¯ -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="status-bar">
                        <p><span class="font-medium">åç‚¹ç»Ÿè®¡:</span> è‡ªåŠ¨ <span id="autoBadCount" class="text-red-500">0</span> ä¸ªï¼Œæ‰‹åŠ¨ <span id="manualBadCount" class="text-blue-500">0</span> ä¸ªï¼Œæ€»è®¡ <span id="totalBadCount" class="text-accent">0</span> ä¸ª</p>
                    </div>
                    <div class="status-bar">
                        <p><span class="font-medium">å½“å‰åƒç´ :</span> X: <span id="currentX">-</span>, Y: <span id="currentY">-</span>, å€¼: <span id="currentValue">-</span></p>
                    </div>
                </div>

                <!-- è°ƒè¯•é¢æ¿ -->
                <div class="debug-panel" id="debugPanel">
                    <p class="font-medium mb-1">å›¾åƒç»Ÿè®¡ (ç­‰å¾…åŠ è½½):</p>
                    <p>æœ€å°å€¼: -, æœ€å¤§å€¼: -, 1%åˆ†ä½: -, 99%åˆ†ä½: -</p>
                </div>

                <!-- åç‚¹åˆ—è¡¨é¢æ¿ï¼ˆæ›¿æ¢åŸå…¨é»‘æç¤ºï¼‰ -->
                <div class="debug-panel" id="badPointListPanel">
                    <p class="font-medium mb-1 text-green-400">ğŸ“Œ åç‚¹åˆ—è¡¨ï¼š</p>
                    <p class="text-gray-300">æš‚æ— åç‚¹æ•°æ®ï¼Œè¯·åŠ è½½å›¾åƒå¹¶æ£€æµ‹/æ ‡è®°</p>
                </div>
            </div>
        </div>

        <!-- é¡µè„š -->
        <footer class="mt-8 text-center text-gray-500 text-sm py-4 border-t">
            <p>åç‚¹æ£€æµ‹ä¸Šä½æœº &copy; 2025_v3 ã€å…¼å®¹640Ã—512/384Ã—288ã€‘</p>
        </footer>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let imageData = null;          // åŸå§‹å›¾åƒæ•°æ®ï¼ˆ16ä½ï¼‰
        let originalData = null;       // åŸå§‹å­—èŠ‚æ•°æ®
        let width = 640;               // å›¾åƒå®½åº¦
        let height = 512;              // å›¾åƒé«˜åº¦
        let autoBadPoints = new Set(); // è‡ªåŠ¨æ£€æµ‹çš„åç‚¹
        let manualBadPoints = new Set(); // æ‰‹åŠ¨æ ‡è®°çš„åç‚¹
        let isMarkingMode = false;     // æ˜¯å¦å¤„äºæ‰‹åŠ¨æ ‡è®°æ¨¡å¼
        let currentX = 0;              // å½“å‰æ ‡è®°ä½ç½®X
        let currentY = 0;              // å½“å‰æ ‡è®°ä½ç½®Y
        let threshold = 50;            // å·®å¼‚é˜ˆå€¼
        let rowMajorOrder = true;      // æ˜¯å¦è¡Œä¼˜å…ˆå­˜å‚¨
        let littleEndian = false;      // æ˜¯å¦å°ç«¯å­—èŠ‚åº
        let imageStats = { min: 0, max: 0, p1: 0, p99: 0 }; // å›¾åƒç»Ÿè®¡ä¿¡æ¯

        // å›¾åƒä¼˜åŒ–å‚æ•°
        let brightness = 0;            // äº®åº¦è°ƒæ•´ (-100è‡³+100)
        let contrast = 100;            // å¯¹æ¯”åº¦è°ƒæ•´ (50è‡³200%)
        let gamma = 1.0;               // ä¼½é©¬æ ¡æ­£ (0.1è‡³3.0)
        let displayMin = 0;            // æ˜¾ç¤ºèŒƒå›´æœ€å°å€¼
        let displayMax = 4095;         // æ˜¾ç¤ºèŒƒå›´æœ€å¤§å€¼

        // ç”»å¸ƒç›¸å…³å˜é‡
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        let scale = 1;                 // ç¼©æ”¾æ¯”ä¾‹
        let offsetX = 0;               // å¹³ç§»Xåç§»
        let offsetY = 0;               // å¹³ç§»Yåç§»
        let isDragging = false;        // æ˜¯å¦æ­£åœ¨æ‹–åŠ¨
        let lastX, lastY;              // ä¸Šä¸€æ¬¡é¼ æ ‡ä½ç½®
        let imageBitmap = null;        // ç”¨äºç»˜åˆ¶çš„å›¾åƒï¼ˆå·²å¤„ç†ä¸º8ä½ï¼‰
        let viewModeIndicator = document.getElementById('viewModeIndicator');
        let markModeIndicator = document.getElementById('markModeIndicator');
        let debugPanel = document.getElementById('debugPanel');
        let badPointListPanel = document.getElementById('badPointListPanel'); // åç‚¹åˆ—è¡¨é¢æ¿

        // DOMå…ƒç´ 
        const fileInput = document.getElementById('fileInput');
        const fileName = document.getElementById('fileName');
        const fileInfo = document.getElementById('fileInfo');
        const widthInput = document.getElementById('widthInput');
        const heightInput = document.getElementById('heightInput');
        const applySizeButton = document.getElementById('applySizeButton');
        const rowMajorOrderCheckbox = document.getElementById('rowMajorOrder');
        const littleEndianCheckbox = document.getElementById('littleEndian');
        const noImageHint = document.getElementById('noImageHint');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const detectButton = document.getElementById('detectButton');
        const saveButton = document.getElementById('saveButton');
        const startMarkingButton = document.getElementById('startMarkingButton');
        const clearManualButton = document.getElementById('clearManualButton');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValue = document.getElementById('thresholdValue');
        const autoBadCount = document.getElementById('autoBadCount');
        const manualBadCount = document.getElementById('manualBadCount');
        const totalBadCount = document.getElementById('totalBadCount');
        const currentXEl = document.getElementById('currentX');
        const currentYEl = document.getElementById('currentY');
        const currentValueEl = document.getElementById('currentValue');
        const neighborhoodSelect = document.getElementById('neighborhoodSelect');
        const autoAdjustButton = document.getElementById('autoAdjustButton');
        const minRangeInput = document.getElementById('minRangeInput');
        const maxRangeInput = document.getElementById('maxRangeInput');

        // å›¾åƒä¼˜åŒ–æ§ä»¶
        const brightnessSlider = document.getElementById('brightnessSlider');
        const brightnessValue = document.getElementById('brightnessValue');
        const contrastSlider = document.getElementById('contrastSlider');
        const contrastValue = document.getElementById('contrastValue');
        const gammaSlider = document.getElementById('gammaSlider');
        const gammaValue = document.getElementById('gammaValue');
        const resetEnhanceButton = document.getElementById('resetEnhanceButton');

        // åˆå§‹åŒ–
        function init() {
            resizeCanvas();
            setupEventListeners();
            // ç»‘å®šåˆ†è¾¨ç‡åˆ‡æ¢æŒ‰é’®äº‹ä»¶
            bindResolutionButtons();
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œè°ƒæ•´ç”»å¸ƒå°ºå¯¸
            window.addEventListener('resize', resizeCanvas);

            // é˜ˆå€¼è°ƒæ•´
            thresholdSlider.addEventListener('input', (e) => {
                threshold = parseInt(e.target.value);
                thresholdValue.textContent = threshold;
            });

            // äº®åº¦è°ƒæ•´
            brightnessSlider.addEventListener('input', (e) => {
                brightness = parseInt(e.target.value);
                brightnessValue.textContent = brightness;
                if (imageData) {
                    updateImage();
                }
            });

            // å¯¹æ¯”åº¦è°ƒæ•´
            contrastSlider.addEventListener('input', (e) => {
                contrast = parseInt(e.target.value);
                contrastValue.textContent = `${contrast}%`;
                if (imageData) {
                    updateImage();
                }
            });

            // ä¼½é©¬è°ƒæ•´
            gammaSlider.addEventListener('input', (e) => {
                gamma = parseFloat(e.target.value);
                gammaValue.textContent = gamma.toFixed(1);
                if (imageData) {
                    updateImage();
                }
            });

            // æ˜¾ç¤ºèŒƒå›´è°ƒæ•´
            minRangeInput.addEventListener('change', (e) => {
                displayMin = parseInt(e.target.value);
                if (imageData) {
                    updateImage();
                }
            });

            maxRangeInput.addEventListener('change', (e) => {
                displayMax = parseInt(e.target.value);
                if (imageData) {
                    updateImage();
                }
            });

            // é‡ç½®ä¼˜åŒ–å‚æ•°
            resetEnhanceButton.addEventListener('click', resetEnhanceParams);

            // è‡ªåŠ¨è°ƒæ•´æŒ‰é’®
            autoAdjustButton.addEventListener('click', autoAdjustImage);

            // è¡Œä¼˜å…ˆå­˜å‚¨é€‰é¡¹
            rowMajorOrderCheckbox.addEventListener('change', (e) => {
                rowMajorOrder = e.target.checked;
                if (originalData) {
                    reloadImageData();
                }
            });

            // å¤§å°ç«¯é€‰æ‹©
            littleEndianCheckbox.addEventListener('change', (e) => {
                littleEndian = e.target.checked;
                if (originalData) {
                    reloadImageData();
                }
            });

            // åº”ç”¨å°ºå¯¸æŒ‰é’®
            applySizeButton.addEventListener('click', () => {
                const newWidth = parseInt(widthInput.value);
                const newHeight = parseInt(heightInput.value);

                if (newWidth > 0 && newHeight > 0) {
                    width = newWidth;
                    height = newHeight;
                    if (originalData) {
                        reloadImageData();
                    }
                } else {
                    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„å®½åº¦å’Œé«˜åº¦');
                }
            });

            // åŠ è½½RAWæ–‡ä»¶
            fileInput.addEventListener('change', handleFileSelect);

            // è‡ªåŠ¨æ£€æµ‹åç‚¹
            detectButton.addEventListener('click', detectBadPoints);

            // å¼€å§‹æ‰‹åŠ¨æ ‡è®°
            startMarkingButton.addEventListener('click', toggleMarkingMode);

            // æ¸…é™¤æ‰‹åŠ¨æ ‡è®°
            clearManualButton.addEventListener('click', clearManualMarkings);

            // ä¿å­˜ç»“æœ
            saveButton.addEventListener('click', saveResults);

            // é¼ æ ‡äº‹ä»¶å¤„ç†
            setupCanvasEvents();
        }

        // æ–°å¢ï¼šç»‘å®šåˆ†è¾¨ç‡å¿«é€Ÿåˆ‡æ¢æŒ‰é’®äº‹ä»¶
        function bindResolutionButtons() {
            const resBtns = document.querySelectorAll('.res-btn');
            resBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const newW = parseInt(btn.dataset.width);
                    const newH = parseInt(btn.dataset.height);
                    widthInput.value = newW;
                    heightInput.value = newH;
                    // é«˜äº®å½“å‰é€‰ä¸­çš„æŒ‰é’®
                    resBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    // è‡ªåŠ¨åº”ç”¨å°ºå¯¸
                    width = newW;
                    height = newH;
                    if (originalData) {
                        reloadImageData();
                    }
                });
            });
        }

        // åˆå§‹åŒ–ç”»å¸ƒå°ºå¯¸
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if (imageBitmap) {
                drawCanvas();
            }
        }

        // è®¾ç½®ç”»å¸ƒäº‹ä»¶
        function setupCanvasEvents() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleMouseWheel);
            window.addEventListener('keydown', handleKeyDown);
        }

        // é‡ç½®ä¼˜åŒ–å‚æ•°
        function resetEnhanceParams() {
            brightness = 0;
            contrast = 100;
            gamma = 1.0;

            brightnessSlider.value = brightness;
            brightnessValue.textContent = brightness;
            contrastSlider.value = contrast;
            contrastValue.textContent = `${contrast}%`;
            gammaSlider.value = gamma;
            gammaValue.textContent = gamma.toFixed(1);

            if (imageData) {
                updateImage();
            }
        }

        // è‡ªåŠ¨è°ƒæ•´å›¾åƒ
        function autoAdjustImage() {
            if (!imageData) return;

            // ä½¿ç”¨1%å’Œ99%åˆ†ä½æ•°ä½œä¸ºæ˜¾ç¤ºèŒƒå›´
            displayMin = imageStats.p1;
            displayMax = imageStats.p99;

            minRangeInput.value = displayMin;
            maxRangeInput.value = displayMax;

            updateImage();
        }

        // é‡æ–°åŠ è½½å›¾åƒæ•°æ®
        function reloadImageData() {
            if (!originalData) return;

            showLoading();

            try {
                // è®¡ç®—æ€»åƒç´ æ•°
                const totalPixels = width * height;

                // è½¬æ¢å­—èŠ‚åºå¹¶å­˜å‚¨å›¾åƒæ•°æ®
                imageData = convertEndianness(originalData, totalPixels);

                // è®¡ç®—å›¾åƒç»Ÿè®¡ä¿¡æ¯
                calculateImageStats();

                // æ›´æ–°å›¾åƒæ˜¾ç¤º
                updateImage();

                resetView();
                hideLoading();
            } catch (error) {
                console.error('é‡æ–°åŠ è½½å›¾åƒå¤±è´¥:', error);
                hideLoading();
            }
        }

        // ä¿®å¤æ ¸å¿ƒï¼šè½¬æ¢å­—èŠ‚åºå‡½æ•° å…¼å®¹åˆ†è¾¨ç‡åˆ‡æ¢ï¼Œæ”¾å®½å­—èŠ‚æ•°æ ¡éªŒ
        function convertEndianness(byteData, totalPixels) {
            const result = new Uint16Array(totalPixels);
            const byteView = new Uint8Array(byteData);

            // âœ… ä¿®å¤ï¼šå…¼å®¹æ–‡ä»¶å­—èŠ‚æ•° >= æ‰€éœ€å­—èŠ‚æ•° å³å¯ï¼Œè§£å†³384*288åŠ è½½æŠ¥é”™é—®é¢˜
            const needBytes = totalPixels * 2;
            if (byteView.length < needBytes) {
                throw new Error(`æ•°æ®ä¸è¶³ï¼šéœ€è¦ ${needBytes} å­—èŠ‚ï¼Œä½†åªæä¾›äº† ${byteView.length} å­—èŠ‚`);
            }

            for (let i = 0; i < totalPixels; i++) {
                const byteOffset = i * 2;

                if (littleEndian) {
                    // å°ç«¯æ¨¡å¼ï¼šä½å­—èŠ‚åœ¨å‰ (LSB first)
                    result[i] = (byteView[byteOffset + 1] << 8) | byteView[byteOffset];
                } else {
                    // å¤§ç«¯æ¨¡å¼ï¼šé«˜å­—èŠ‚åœ¨å‰ (MSB first)
                    result[i] = (byteView[byteOffset] << 8) | byteView[byteOffset + 1];
                }
            }

            return result;
        }

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        async function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            showLoading();
            fileName.textContent = file.name;
            fileInfo.classList.remove('hidden');

            try {
                // è¯»å–åŸå§‹å­—èŠ‚æ•°æ®
                const arrayBuffer = await readFileAsync(file);
                originalData = arrayBuffer;

                // ä½¿ç”¨ç”¨æˆ·æŒ‡å®šçš„å°ºå¯¸
                width = parseInt(widthInput.value);
                height = parseInt(heightInput.value);

                // è½¬æ¢å­—èŠ‚åºå¹¶å­˜å‚¨å›¾åƒæ•°æ®
                const totalPixels = width * height;
                imageData = convertEndianness(originalData, totalPixels);

                // è®¡ç®—å›¾åƒç»Ÿè®¡ä¿¡æ¯
                calculateImageStats();

                // è‡ªåŠ¨è°ƒæ•´æ˜¾ç¤ºèŒƒå›´
                autoAdjustImage();

                // é‡ç½®çŠ¶æ€
                autoBadPoints.clear();
                manualBadPoints.clear();
                updateBadCount();
                updateBadPointList(); // é‡ç½®åç‚¹åˆ—è¡¨

                // åˆ›å»ºå›¾åƒå¹¶ç»˜åˆ¶
                updateImage();
                resetView();

                // å¯ç”¨æŒ‰é’®
                detectButton.disabled = false;
                startMarkingButton.disabled = false;
                saveButton.disabled = false;
                clearManualButton.disabled = false;
                autoAdjustButton.disabled = false;

                noImageHint.classList.add('hidden');
                viewModeIndicator.classList.remove('hidden');
            } catch (error) {
                console.error('åŠ è½½æ–‡ä»¶å¤±è´¥:', error);
                alert('åŠ è½½æ–‡ä»¶å¤±è´¥: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        // è®¡ç®—å›¾åƒç»Ÿè®¡ä¿¡æ¯
        function calculateImageStats() {
            if (!imageData) return;

            // å¤åˆ¶æ•°æ®å¹¶æ’åº
            const sortedValues = new Uint16Array(imageData);
            sortedValues.sort();

            const minValue = sortedValues[0];
            const maxValue = sortedValues[sortedValues.length - 1];
            const p1 = sortedValues[Math.floor(sortedValues.length * 0.01)];
            const p99 = sortedValues[Math.floor(sortedValues.length * 0.99)];

            // ä¿å­˜ç»Ÿè®¡ä¿¡æ¯
            imageStats = { min: minValue, max: maxValue, p1: p1, p99: p99 };

            debugPanel.innerHTML = `
                <p class="font-medium mb-1">å›¾åƒç»Ÿè®¡ (${width}Ã—${height}):</p>
                <p>æœ€å°å€¼: ${minValue}, æœ€å¤§å€¼: ${maxValue}</p>
                <p>1%åˆ†ä½: ${p1}, 99%åˆ†ä½: ${p99}</p>
                <p class="text-xs text-gray-400">æç¤ºï¼šè‹¥æœ€å¤§å€¼<100ï¼Œå¯èƒ½å­—èŠ‚åº/å­˜å‚¨é¡ºåºé”™è¯¯</p>
            `;
        }

        // æ›´æ–°å›¾åƒæ˜¾ç¤º
        async function updateImage() {
            if (!imageData) return;

            showLoading();

            try {
                await createImageBitmapFromData();
                drawCanvas();
                hideLoading();
            } catch (error) {
                console.error('æ›´æ–°å›¾åƒå¤±è´¥:', error);
                hideLoading();
            }
        }

        // ä»åŸå§‹æ•°æ®åˆ›å»ºå›¾åƒ
        async function createImageBitmapFromData() {
            // åˆ›å»ºRGBAå›¾åƒæ•°æ®
            const rgbaData = new Uint8ClampedArray(width * height * 4);
            const contrastFactor = contrast / 100;
            const brightnessOffset = brightness * 2.55; // -100åˆ°100æ˜ å°„åˆ°-255åˆ°255

            // è®¡ç®—æ˜¾ç¤ºèŒƒå›´
            const range = Math.max(1, displayMax - displayMin);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // æ ¹æ®å­˜å‚¨é¡ºåºè®¡ç®—ç´¢å¼•
                    let index;
                    if (rowMajorOrder) {
                        index = y * width + x;
                    } else {
                        index = x * height + y;
                    }

                    // è·å–åŸå§‹åƒç´ å€¼
                    let value = imageData[index];

                    // åº”ç”¨æ˜¾ç¤ºèŒƒå›´é™åˆ¶
                    value = Math.max(displayMin, Math.min(displayMax, value));

                    // å½’ä¸€åŒ–åˆ°0-1èŒƒå›´
                    let normalized = (value - displayMin) / range;

                    // åº”ç”¨ä¼½é©¬æ ¡æ­£
                    normalized = Math.pow(normalized, 1 / gamma);

                    // åº”ç”¨å¯¹æ¯”åº¦è°ƒæ•´
                    normalized = 0.5 + contrastFactor * (normalized - 0.5);

                    // åº”ç”¨äº®åº¦è°ƒæ•´
                    normalized += brightnessOffset / 255;

                    // é™åˆ¶åœ¨0-1èŒƒå›´å†…
                    normalized = Math.max(0, Math.min(1, normalized));

                    // è½¬æ¢ä¸ºå­—èŠ‚å€¼
                    const byteValue = Math.floor(normalized * 255);

                    // è®¾ç½®RGBAå€¼ï¼ˆç°åº¦å›¾åƒï¼‰
                    const rgbaIndex = (y * width + x) * 4;
                    rgbaData[rgbaIndex] = byteValue;
                    rgbaData[rgbaIndex + 1] = byteValue;
                    rgbaData[rgbaIndex + 2] = byteValue;
                    rgbaData[rgbaIndex + 3] = 255;
                }
            }

            // åˆ›å»ºImageDataå¯¹è±¡
            const imageDataObj = new ImageData(rgbaData, width, height);

            // åˆ›å»ºImageBitmapï¼ˆç”¨äºåç»­ç»˜åˆ¶ï¼‰
            imageBitmap = await createImageBitmap(imageDataObj);
        }

        // ç»˜åˆ¶ç”»å¸ƒ
        function drawCanvas() {
            if (!imageBitmap) return;

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // åº”ç”¨å˜æ¢
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(imageBitmap, 0, 0);

            // ç»˜åˆ¶è‡ªåŠ¨æ£€æµ‹çš„åç‚¹ï¼ˆçº¢è‰²ï¼‰
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
            autoBadPoints.forEach(point => {
                const [y, x] = point.split(',').map(Number);
                ctx.beginPath();
                ctx.arc(x + 0.5, y + 0.5, 2 / scale, 0, Math.PI * 2);
                ctx.fill();
            });

            // ç»˜åˆ¶æ‰‹åŠ¨æ ‡è®°çš„åç‚¹ï¼ˆè“è‰²ï¼‰
            ctx.fillStyle = 'rgba(0, 204, 255, 1)';
            manualBadPoints.forEach(point => {
                const [y, x] = point.split(',').map(Number);
                ctx.beginPath();
                ctx.arc(x + 0.5, y + 0.5, 2 / scale, 0, Math.PI * 2);
                ctx.fill();
            });

            // ç»˜åˆ¶å½“å‰æ ‡è®°ä½ç½®ï¼ˆç»¿è‰²åå­—ï¼‰
            if (isMarkingMode) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 1)';
                ctx.lineWidth = 1 / scale;

                // æ°´å¹³çº¿
                ctx.beginPath();
                ctx.moveTo(currentX - 3 / scale + 0.5, currentY + 0.5);
                ctx.lineTo(currentX + 3 / scale + 0.5, currentY + 0.5);
                ctx.stroke();

                // å‚ç›´çº¿
                ctx.beginPath();
                ctx.moveTo(currentX + 0.5, currentY - 3 / scale + 0.5);
                ctx.lineTo(currentX + 0.5, currentY + 3 / scale + 0.5);
                ctx.stroke();
            }

            ctx.restore();
        }

        // è‡ªåŠ¨æ£€æµ‹åç‚¹ï¼ˆæ£€æµ‹åæ›´æ–°åç‚¹åˆ—è¡¨ï¼‰
        async function detectBadPoints() {
            if (!imageData) return;

            showLoading();
            detectButton.disabled = true;

            try {
                const neighborhoodSize = parseInt(neighborhoodSelect.value);
                const halfNeighborhood = Math.floor(neighborhoodSize / 2);
                const badPoints = new Set();

                // åç‚¹æ£€æµ‹ç®—æ³•
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const centerIndex = rowMajorOrder ? (y * width + x) : (x * height + y);
                        const centerValue = imageData[centerIndex];
                        let aboveThresholdCount = 0;
                        let validNeighbors = 0;

                        // æ£€æŸ¥é‚»åŸŸ
                        for (let ny = -halfNeighborhood; ny <= halfNeighborhood; ny++) {
                            for (let nx = -halfNeighborhood; nx <= halfNeighborhood; nx++) {
                                if (nx === 0 && ny === 0) continue; // è·³è¿‡ä¸­å¿ƒåƒç´ 

                                const neighborX = x + nx;
                                const neighborY = y + ny;

                                // æ£€æŸ¥è¾¹ç•Œ
                                if (neighborX >= 0 && neighborX < width &&
                                    neighborY >= 0 && neighborY < height) {
                                    const neighborIndex = rowMajorOrder ?
                                        (neighborY * width + neighborX) :
                                        (neighborX * height + neighborY);
                                    const neighborValue = imageData[neighborIndex];

                                    if (Math.abs(centerValue - neighborValue) > threshold) {
                                        aboveThresholdCount++;
                                    }
                                    validNeighbors++;
                                }
                            }
                        }

                        // å¦‚æœè¶…è¿‡ä¸€åŠçš„é‚»åŸŸç‚¹ä¸ä¸­å¿ƒç‚¹å·®å¼‚è¶…è¿‡é˜ˆå€¼ï¼Œåˆ™æ ‡è®°ä¸ºåç‚¹
                        if (validNeighbors > 0 && aboveThresholdCount > validNeighbors / 2) {
                            badPoints.add(`${y},${x}`);
                        }
                    }
                }

                autoBadPoints = badPoints;
                updateBadCount();
                updateBadPointList(); // æ£€æµ‹åæ›´æ–°åç‚¹åˆ—è¡¨
                drawCanvas();
            } catch (error) {
                console.error('æ£€æµ‹åç‚¹å¤±è´¥:', error);
                alert('æ£€æµ‹åç‚¹å¤±è´¥: ' + error.message);
            } finally {
                detectButton.disabled = false;
                hideLoading();
            }
        }

        // åˆ‡æ¢æ ‡è®°æ¨¡å¼ï¼ˆæ‰‹åŠ¨æ ‡è®°åæ›´æ–°åç‚¹åˆ—è¡¨ï¼‰
        function toggleMarkingMode() {
            if (!imageData) return;

            if (isMarkingMode) {
                // é€€å‡ºæ ‡è®°æ¨¡å¼
                isMarkingMode = false;
                startMarkingButton.innerHTML = '<i class="fa fa-mouse-pointer"></i> å¼€å§‹æ‰‹åŠ¨æ ‡è®°';
                startMarkingButton.classList.remove('bg-primary', 'text-white');
                startMarkingButton.classList.add('border', 'border-gray-300', 'hover:bg-gray-100');
                currentXEl.textContent = '-';
                currentYEl.textContent = '-';
                currentValueEl.textContent = '-';
                document.body.style.cursor = '';
                viewModeIndicator.classList.remove('hidden');
                markModeIndicator.classList.add('hidden');
            } else {
                // è¿›å…¥æ ‡è®°æ¨¡å¼
                isMarkingMode = true;
                startMarkingButton.innerHTML = '<i class="fa fa-stop"></i> é€€å‡ºæ‰‹åŠ¨æ ‡è®°';
                startMarkingButton.classList.remove('border', 'border-gray-300', 'hover:bg-gray-100');
                startMarkingButton.classList.add('bg-primary', 'text-white');

                // è®¾ç½®åˆå§‹ä½ç½®ä¸ºä¸­å¿ƒ
                currentX = Math.floor(width / 2);
                currentY = Math.floor(height / 2);
                updateCurrentPositionInfo();
                document.body.style.cursor = 'crosshair';
                viewModeIndicator.classList.add('hidden');
                markModeIndicator.classList.remove('hidden');
            }

            drawCanvas();
        }

        // æ¸…é™¤æ‰‹åŠ¨æ ‡è®°ï¼ˆæ¸…é™¤åæ›´æ–°åç‚¹åˆ—è¡¨ï¼‰
        function clearManualMarkings() {
            if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰æ‰‹åŠ¨æ ‡è®°çš„åç‚¹å—ï¼Ÿ')) {
                manualBadPoints.clear();
                updateBadCount();
                updateBadPointList(); // æ¸…é™¤åæ›´æ–°åç‚¹åˆ—è¡¨
                drawCanvas();
            }
        }

        // ä¿å­˜ç»“æœï¼ˆåç‚¹æ ‡è®°å€¼æ”¹ä¸º0x1000ï¼‰
        function saveResults() {
            if (!imageData) return;

            showLoading();

            try {
                // è®¡ç®—æ€»åƒç´ æ•°å’Œå­—èŠ‚æ•°
                const totalPixels = width * height;
                const totalBytes = totalPixels * 2;

                // åˆ›å»ºåç‚¹æ ‡å¿—æ•°æ®
                const badFlagData = new Uint16Array(totalPixels);

                // åˆå¹¶è‡ªåŠ¨å’Œæ‰‹åŠ¨æ ‡è®°çš„åç‚¹
                const allBadPoints = new Set([...autoBadPoints, ...manualBadPoints]);

                // æ ¸å¿ƒä¿®æ”¹ï¼šåç‚¹æ ‡è®°å€¼ä»0x8000æ”¹ä¸º0x1000
                allBadPoints.forEach(point => {
                    const [y, x] = point.split(',').map(Number);
                    let index;

                    if (rowMajorOrder) {
                        index = y * width + x;
                    } else {
                        index = x * height + y;
                    }

                    badFlagData[index] = 0x1000; // åŸ0x8000ï¼Œå·²æ”¹ä¸º0x1000
                });

                // æ ¹æ®å­—èŠ‚åºè½¬æ¢ä¸ºå­—èŠ‚æ•°æ®
                const byteData = new Uint8Array(totalBytes);
                for (let i = 0; i < totalPixels; i++) {
                    const byteOffset = i * 2;
                    const value = badFlagData[i];

                    if (littleEndian) {
                        byteData[byteOffset] = value & 0xFF;
                        byteData[byteOffset + 1] = (value >> 8) & 0xFF;
                    } else {
                        byteData[byteOffset] = (value >> 8) & 0xFF;
                        byteData[byteOffset + 1] = value & 0xFF;
                    }
                }

                // åˆ›å»ºBlobå¹¶ä¸‹è½½
                const blob = new Blob([byteData.buffer], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'bad_points.bin';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('ä¿å­˜æ–‡ä»¶å¤±è´¥:', error);
                alert('ä¿å­˜æ–‡ä»¶å¤±è´¥: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
        function handleMouseDown(e) {
            if (!imageData) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // è®¡ç®—å›¾åƒåæ ‡
            const imgX = Math.floor((mouseX - offsetX) / scale);
            const imgY = Math.floor((mouseY - offsetY) / scale);

            if (isMarkingMode) {
                // æ‰‹åŠ¨æ ‡è®°æ¨¡å¼ä¸‹ç‚¹å‡»æ›´æ–°ä½ç½®
                if (imgX >= 0 && imgX < width && imgY >= 0 && imgY < height) {
                    currentX = imgX;
                    currentY = imgY;
                    updateCurrentPositionInfo();
                    drawCanvas();
                }
            } else {
                // å¼€å§‹æ‹–åŠ¨
                isDragging = true;
                lastX = mouseX;
                lastY = mouseY;
                canvas.style.cursor = 'grabbing';
            }
        }

        // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
        function handleMouseMove(e) {
            if (!imageData) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (isDragging) {
                // è®¡ç®—åç§»é‡
                const dx = mouseX - lastX;
                const dy = mouseY - lastY;
                offsetX += dx;
                offsetY += dy;
                lastX = mouseX;
                lastY = mouseY;
                drawCanvas();
                return;
            }

            // æ›´æ–°åƒç´ ä¿¡æ¯
            const x = Math.floor((mouseX - offsetX) / scale);
            const y = Math.floor((mouseY - offsetY) / scale);

            if (x >= 0 && x < width && y >= 0 && y < height) {
                const index = rowMajorOrder ? (y * width + x) : (x * height + y);
                const value = imageData[index];
                currentXEl.textContent = x;
                currentYEl.textContent = y;
                currentValueEl.textContent = value;
            } else {
                currentXEl.textContent = '-';
                currentYEl.textContent = '-';
                currentValueEl.textContent = '-';
            }
        }

        // é¼ æ ‡é‡Šæ”¾äº‹ä»¶
        function handleMouseUp() {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'grab';
            }
        }

        // é¼ æ ‡æ»šè½®äº‹ä»¶
        function handleMouseWheel(e) {
            if (!imageData) return;
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // è®¡ç®—é¼ æ ‡åœ¨å›¾åƒä¸Šçš„ä½ç½®
            const imgX = (mouseX - offsetX) / scale;
            const imgY = (mouseY - offsetY) / scale;

            // ç¼©æ”¾å› å­
            const zoomIntensity = 0.1;
            if (e.deltaY < 0) {
                scale *= (1 + zoomIntensity);
            } else {
                scale /= (1 + zoomIntensity);
            }

            // é™åˆ¶ç¼©æ”¾èŒƒå›´
            scale = Math.min(Math.max(0.1, scale), 10);

            // è°ƒæ•´åç§»é‡
            offsetX = mouseX - imgX * scale;
            offsetY = mouseY - imgY * scale;

            drawCanvas();
        }

        // é”®ç›˜äº‹ä»¶ï¼ˆæ‰‹åŠ¨æ ‡è®°åæ›´æ–°åç‚¹åˆ—è¡¨ï¼‰
        function handleKeyDown(e) {
            if (!isMarkingMode || !imageData) return;

            let moved = false;

            // æ–¹å‘é”®ç§»åŠ¨
            switch (e.key) {
                case 'ArrowUp':
                    if (currentY > 0) {
                        currentY--;
                        moved = true;
                    }
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    if (currentY < height - 1) {
                        currentY++;
                        moved = true;
                    }
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                    if (currentX > 0) {
                        currentX--;
                        moved = true;
                    }
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    if (currentX < width - 1) {
                        currentX++;
                        moved = true;
                    }
                    e.preventDefault();
                    break;
                case ' ': // ç©ºæ ¼é”®æ ‡è®°/å–æ¶ˆæ ‡è®°
                    const point = `${currentY},${currentX}`;
                    if (manualBadPoints.has(point)) {
                        manualBadPoints.delete(point);
                    } else {
                        manualBadPoints.add(point);
                    }
                    updateBadCount();
                    updateBadPointList(); // æ‰‹åŠ¨æ ‡è®°åæ›´æ–°åç‚¹åˆ—è¡¨
                    drawCanvas();
                    e.preventDefault();
                    break;
                case 'Enter': // å›è½¦é”®é€€å‡ºæ ‡è®°æ¨¡å¼
                    toggleMarkingMode();
                    e.preventDefault();
                    break;
            }

            // æ›´æ–°ä½ç½®ä¿¡æ¯å’Œç”»å¸ƒ
            if (moved) {
                updateCurrentPositionInfo();
                drawCanvas();
            }
        }

        // é‡ç½®è§†å›¾
        function resetView() {
            // è®¡ç®—åˆå§‹ç¼©æ”¾å’Œåç§»ï¼Œä½¿å›¾åƒå±…ä¸­æ˜¾ç¤º
            const scaleX = canvas.width / width;
            const scaleY = canvas.height / height;
            scale = Math.min(scaleX, scaleY);

            offsetX = (canvas.width - width * scale) / 2;
            offsetY = (canvas.height - height * scale) / 2;
            drawCanvas();
        }

        // æ›´æ–°åç‚¹è®¡æ•°
        function updateBadCount() {
            const autoCount = autoBadPoints.size;
            const manualCount = manualBadPoints.size;
            const totalCount = autoCount + manualCount;

            autoBadCount.textContent = autoCount;
            manualBadCount.textContent = manualCount;
            totalBadCount.textContent = totalCount;
        }

        // æ ¸å¿ƒæ–°å¢ï¼šæ›´æ–°åç‚¹åˆ—è¡¨æ˜¾ç¤ºï¼ˆæ¯è¡Œæ˜¾ç¤ºåæ ‡+ç±»å‹ï¼Œè‡ªåŠ¨çº¢/æ‰‹åŠ¨è“ï¼‰
        function updateBadPointList() {
            // æ”¶é›†è‡ªåŠ¨æ£€æµ‹çš„åç‚¹ï¼ˆæ ¼å¼ï¼š(X,Y) è‡ªåŠ¨ï¼Œçº¢è‰²æ ·å¼ï¼‰
            const autoPoints = Array.from(autoBadPoints).map(point => {
                const [y, x] = point.split(',').map(Number);
                return `<div class="text-red-500">(${x}, ${y}) è‡ªåŠ¨</div>`;
            });

            // æ”¶é›†æ‰‹åŠ¨æ ‡è®°çš„åç‚¹ï¼ˆæ ¼å¼ï¼š(X,Y) æ‰‹åŠ¨ï¼Œè“è‰²æ ·å¼ï¼‰
            const manualPoints = Array.from(manualBadPoints).map(point => {
                const [y, x] = point.split(',').map(Number);
                return `<div class="text-blue-500">(${x}, ${y}) æ‰‹åŠ¨</div>`;
            });

            // åˆå¹¶æ‰€æœ‰åç‚¹
            const allPoints = [...autoPoints, ...manualPoints];

            // æ›´æ–°é¢æ¿å†…å®¹
            if (allPoints.length === 0) {
                badPointListPanel.innerHTML = `
                    <p class="font-medium mb-1 text-green-400">ğŸ“Œ åç‚¹åˆ—è¡¨ï¼š</p>
                    <p class="text-gray-300">æš‚æ— åç‚¹æ•°æ®ï¼Œè¯·åŠ è½½å›¾åƒå¹¶æ£€æµ‹/æ ‡è®°</p>
                `;
            } else {
                badPointListPanel.innerHTML = `
                    <p class="font-medium mb-1 text-green-400">ğŸ“Œ åç‚¹åˆ—è¡¨ï¼š</p>
                    <div class="text-gray-300">å…± ${allPoints.length} ä¸ªåç‚¹ï¼š</div>
                    <div class="flex flex-col gap-1 mt-1">${allPoints.join('')}</div>
                `;
            }
        }

        // æ›´æ–°å½“å‰ä½ç½®ä¿¡æ¯
        function updateCurrentPositionInfo() {
            if (!imageData) return;

            currentXEl.textContent = currentX;
            currentYEl.textContent = currentY;

            // æ ¹æ®å­˜å‚¨é¡ºåºè®¡ç®—ç´¢å¼•
            let index;
            if (rowMajorOrder) {
                index = currentY * width + currentX;
            } else {
                index = currentX * height + currentY;
            }

            currentValueEl.textContent = imageData[index];
        }

        // æ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºå™¨
        function showLoading() {
            loadingIndicator.classList.remove('hidden');
        }

        // éšè—åŠ è½½æŒ‡ç¤ºå™¨
        function hideLoading() {
            loadingIndicator.classList.add('hidden');
        }

        // å¼‚æ­¥è¯»å–æ–‡ä»¶
        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsArrayBuffer(file);
            });
        }

        // åˆå§‹åŒ–åº”ç”¨
        init();
    </script>
</body>
</html>
