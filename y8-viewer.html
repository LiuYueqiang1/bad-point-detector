<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŸå§‹Y8å›¾åƒè¯»å–å·¥å…· (ç²¾å‡†åƒç´ æŸ¥çœ‹+åç‚¹æ ‡è®°)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#36CFC9',
                        accent: '#FF7D00',
                        dark: '#1D2129',
                        light: '#F2F3F5'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .btn-short:active { @apply bg-gray-300 scale-95 transition-all duration-100; }
            .content-auto {
                content-visibility: auto;
            }
            .canvas-container {
                @apply relative border border-gray-300 rounded-lg overflow-hidden bg-gray-100;
            }
            .control-panel {
                @apply bg-white p-4 rounded-lg shadow-md;
            }
            .btn-primary {
                @apply bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded transition-all duration-200 flex items-center justify-center gap-2;
            }
            .btn-secondary {
                @apply bg-white border border-gray-300 hover:bg-gray-100 px-4 py-2 rounded transition-all duration-200 flex items-center justify-center gap-2;
            }
            .btn-accent {
                @apply bg-accent hover:bg-accent/90 text-white px-4 py-2 rounded transition-all duration-200 flex items-center justify-center gap-2;
            }
            .btn-short {
                @apply bg-gray-50 border border-gray-300 hover:bg-gray-200 px-2 py-1 rounded text-sm transition-all;
            }
            .btn-short-active {
                @apply bg-primary text-white border-primary hover:bg-primary/90 !important;
            }
            .status-bar {
                @apply bg-light p-2 rounded text-sm border border-gray-200;
            }
            .debug-panel {
                @apply bg-dark text-white p-3 rounded-lg text-sm font-mono overflow-auto max-h-40;
            }
            .bad-point-panel {
                @apply bg-dark text-white p-3 rounded-lg text-sm font-mono overflow-auto max-h-60;
            }
            .nav-hint {
                @apply bg-accent/90 text-white px-3 py-1 rounded text-sm absolute top-2 right-2;
            }
            .select-hint {
                @apply bg-blue-600/90 text-white px-3 py-1 rounded text-sm absolute top-2 right-24;
            }
            .mark-mode-hint {
                @apply bg-red-500/90 text-white px-3 py-1 rounded text-sm absolute top-2 left-2;
            }
            .view-mode-hint {
                @apply bg-black/70 text-white px-3 py-1 rounded text-sm absolute top-2 left-2;
            }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div class="container mx-auto px-4 py-6 max-w-7xl">
        <header class="mb-6">
            <h1 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-dark flex items-center gap-3">
                <i class="fa fa-file-image-o text-primary"></i>
                åŸå§‹Y8å›¾åƒè¯»å–å·¥å…· (ç²¾å‡†åƒç´ æŸ¥çœ‹+åç‚¹æ ‡è®°)
            </h1>
            <p class="text-gray-500 mt-1">8bitç°åº¦åŸå§‹æ˜¾ç¤º Â· åƒç´ çº§ç²¾å‡†æŸ¥çœ‹ Â· åç‚¹è‡ªåŠ¨æ£€æµ‹/æ‰‹åŠ¨æ ‡è®° Â· 16bitæ©ç ä¿å­˜</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <div class="lg:col-span-1 space-y-4">
                <!-- æ–‡ä»¶æ“ä½œé¢æ¿ -->
                <div class="control-panel">
                    <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">æ–‡ä»¶æ“ä½œ</h2>
                    <div class="space-y-3">
                        <label class="btn-primary w-full cursor-pointer">
                            <i class="fa fa-file-image-o"></i> åŠ è½½Y8å›¾åƒæ–‡ä»¶
                            <input type="file" id="fileInput" accept=".raw,.bin,.dat,.y8" class="hidden">
                        </label>
                        <div id="fileInfo" class="text-sm text-gray-500">
                            <p id="fileName" class="truncate">æœªé€‰æ‹©æ–‡ä»¶</p>
                            <div class="grid grid-cols-2 gap-2 mt-2">
                                <div>
                                    <label class="block text-xs text-gray-500">å®½åº¦</label>
                                    <input type="number" id="widthInput" class="w-full text-sm border rounded px-2 py-1" value="640" min="1">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-500">é«˜åº¦</label>
                                    <input type="number" id="heightInput" class="w-full text-sm border rounded px-2 py-1" value="512" min="1">
                                </div>
                            </div>
                            <div class="flex gap-2 mt-2">
                                <button id="size640512" class="btn-short flex-1 btn-short-active">640Ã—512</button>
                                <button id="size384288" class="btn-short flex-1">384Ã—288</button>
                                <button id="size12801024" class="btn-short flex-1">1280Ã—1024</button>
                            </div>
                            <div class="space-y-2 mt-3">
                                <div class="flex items-center gap-2 p-2 bg-gray-50 rounded border border-gray-200">
                                    <input type="checkbox" id="rowMajorOrder" checked>
                                    <label for="rowMajorOrder" class="text-sm">è¡Œä¼˜å…ˆå­˜å‚¨</label>
                                </div>
                                <div class="flex items-center gap-2 p-2 bg-gray-50 rounded border border-gray-200">
                                    <input type="checkbox" id="littleEndian">
                                    <label for="littleEndian" class="text-sm">å°ç«¯å­—èŠ‚åº</label>
                                    <span class="text-[10px] text-gray-400">(é»˜è®¤å¤§ç«¯)</span>
                                </div>
                                <div class="flex items-center gap-2 p-2 bg-gray-50 rounded border border-gray-200 text-gray-400">
                                    <i class="fa fa-info-circle"></i>
                                    <label class="text-sm">Y8æ ¼å¼ï¼šå•å­—èŠ‚æ— å¤§å°ç«¯ï¼Œ0=é»‘/255=ç™½</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- æ‰‹åŠ¨æ ‡è®°é¢æ¿ -->
                <div class="control-panel">
                    <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">æ‰‹åŠ¨æ ‡è®°</h2>
                    <div class="space-y-3">
                        <button id="startMarkingButton" class="btn-secondary w-full" disabled>
                            <i class="fa fa-mouse-pointer"></i> å¼€å§‹æ‰‹åŠ¨æ ‡è®°
                        </button>
                        <button id="clearManualButton" class="btn-secondary w-full" disabled>
                            <i class="fa fa-eraser"></i> æ¸…é™¤æ‰‹åŠ¨æ ‡è®°
                        </button>
                        <button id="saveBadMaskButton" class="btn-accent w-full" disabled>
                            <i class="fa fa-save"></i> ä¿å­˜16bitåç‚¹æ©ç 
                        </button>
                    </div>
                </div>

                <!-- åç‚¹æ£€æµ‹å‚æ•°é¢æ¿ -->
                <div class="control-panel">
                    <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">æ£€æµ‹å‚æ•°</h2>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">å·®å¼‚é˜ˆå€¼ (1-50)</label>
                            <div class="flex items-center gap-2">
                                <!-- æ–°å¢ï¼šå‡1æŒ‰é’® -->
                                <button id="thresholdMinus" class="btn-short w-8 h-8 p-0 flex items-center justify-center">-1</button>
                                <input type="range" id="thresholdSlider" min="1" max="50" value="20" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                <!-- æ–°å¢ï¼šåŠ 1æŒ‰é’® -->
                                <button id="thresholdPlus" class="btn-short w-8 h-8 p-0 flex items-center justify-center">+1</button>
                                <span id="thresholdValue" class="text-sm font-medium min-w-[40px] text-center">20</span>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">é‚»åŸŸå¤§å°</label>
                            <select id="neighborhoodSelect" class="w-full text-sm border rounded px-2 py-1">
                                <option value="3">3Ã—3</option>
                                <option value="5" selected>5Ã—5</option>
                                <option value="7">7Ã—7</option>
                            </select>
                        </div>
                        <button id="detectButton" class="btn-primary w-full" disabled>
                            <i class="fa fa-magic"></i> è‡ªåŠ¨æ£€æµ‹åç‚¹
                        </button>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-3 space-y-4">
                <div class="canvas-container" style="height: 600px;">
                    <canvas id="imageCanvas" class="w-full h-full"></canvas>
                    <div id="loadingIndicator" class="absolute inset-0 bg-black/50 flex items-center justify-center hidden">
                        <div class="bg-white p-4 rounded-lg flex items-center gap-3">
                            <i class="fa fa-circle-o-notch fa-spin text-primary text-xl"></i>
                            <span>åŠ è½½åŸå§‹å›¾åƒä¸­...</span>
                        </div>
                    </div>
                    <div id="noImageHint" class="absolute inset-0 flex flex-col items-center justify-center text-gray-400">
                        <i class="fa fa-picture-o text-5xl mb-3"></i>
                        <p>è¯·åŠ è½½Y8æ ¼å¼åŸå§‹å›¾åƒæ–‡ä»¶</p>
                    </div>
                    <!-- æ¨¡å¼æç¤ºï¼šäº’æ–¥æ˜¾ç¤º -->
                    <div class="view-mode-hint hidden" id="viewModeIndicator">
                        æŸ¥çœ‹æ¨¡å¼ï¼šæ»šè½®ç¼©æ”¾+å·¦é”®æ‹–åŠ¨ | ç‚¹å‡»åƒç´ é€‰ä¸­ â†’ ç©ºæ ¼å¼€å¯é”®ç›˜å¯¼èˆª | ESCé€€å‡º
                    </div>
                    <div class="mark-mode-hint hidden" id="markModeIndicator">
                        æ ‡è®°æ¨¡å¼ï¼šæ–¹å‘é”®ç§»åŠ¨ | ç©ºæ ¼æ ‡è®°/å–æ¶ˆ | å›è½¦é€€å‡º | æ‹–æ‹½å¹³ç§»/æ»šè½®ç¼©æ”¾
                    </div>
                    <div class="nav-hint hidden" id="keyboardNavHint">
                        <i class="fa fa-keyboard-o"></i> é”®ç›˜å¯¼èˆªä¸­ï¼šâ†‘â†“â†â†’ç§»åŠ¨åƒç´  | ESCé€€å‡º
                    </div>
                    <div class="select-hint hidden" id="pixelSelectHint">
                        <i class="fa fa-check-circle"></i> å·²é€‰ä¸­åƒç´  | æŒ‰ç©ºæ ¼å¼€å¯é”®ç›˜å¯¼èˆª
                    </div>
                </div>

                <!-- åŒçŠ¶æ€æ ï¼šåƒç´ ä¿¡æ¯ + åç‚¹ç»Ÿè®¡ -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="status-bar">
                        <p><span class="font-medium">å½“å‰åƒç´ ä¿¡æ¯:</span> X: <span id="currentX">-</span>, Y: <span id="currentY">-</span>, åŸå§‹ç°åº¦å€¼: <span id="currentValue">-</span> (0~255)</p>
                    </div>
                    <div class="status-bar">
                        <p><span class="font-medium">åç‚¹ç»Ÿè®¡:</span> è‡ªåŠ¨ <span id="autoBadCount" class="text-red-500">0</span> ä¸ªï¼Œæ‰‹åŠ¨ <span id="manualBadCount" class="text-blue-500">0</span> ä¸ªï¼Œæ€»è®¡ <span id="totalBadCount" class="text-accent">0</span> ä¸ª <span class="text-gray-500">( <span id="badPercentage">0.0000</span>% )</span></p>
                    </div>
                </div>

                <!-- å›¾åƒç»Ÿè®¡é¢æ¿ -->
                <div class="debug-panel" id="debugPanel">
                    <p class="font-medium mb-1">å›¾åƒç»Ÿè®¡ (ç­‰å¾…åŠ è½½):</p>
                    <p>åˆ†è¾¨ç‡: - Ã— - | æœ€å°ç°åº¦: -, æœ€å¤§ç°åº¦: -, 1%åˆ†ä½: -, 99%åˆ†ä½: -</p>
                </div>

                <!-- åç‚¹åˆ—è¡¨é¢æ¿ï¼šç‚¹å‡»åæ ‡è·³è½¬æ”¾å¤§ -->
                <div class="bad-point-panel" id="badPointListPanel">
                    <p class="font-medium mb-1 text-green-400">ğŸ“Œ åç‚¹åˆ—è¡¨ï¼š</p>
                    <p class="text-gray-300">æš‚æ— åç‚¹æ•°æ®ï¼Œè¯·åŠ è½½å›¾åƒå¹¶æ£€æµ‹/æ ‡è®°</p>
                </div>
            </div>
        </div>

        <footer class="mt-8 text-center text-gray-500 text-sm py-4 border-t">
            <p>åŸå§‹Y8å›¾åƒè¯»å–å·¥å…· &copy; 2026 | ç²¾å‡†åƒç´ æŸ¥çœ‹+åç‚¹æ ‡è®°ç‰ˆ | 16bitæ©ç ä¿å­˜</p>
        </footer>
    </div>

    <script>
        // ã€åŸæœ‰Y8å·¥å…·å…¨å±€å˜é‡ã€‘
        let imageData = null;          // Y8åŸå§‹8ä½ç°åº¦æ•°æ®ï¼ˆUint8Arrayï¼‰
        let originalData = null;       // æ–‡ä»¶åŸå§‹ArrayBuffer
        let width = 640;               // é»˜è®¤åˆ†è¾¨ç‡ 640*512
        let height = 512;              // é»˜è®¤åˆ†è¾¨ç‡
        let rowMajorOrder = true;      // æ˜¯å¦è¡Œä¼˜å…ˆå­˜å‚¨
        let littleEndian = false;      // æ–°å¢ï¼šå­—èŠ‚åºï¼ˆä¸ºäº†åŒ¹é…16bitä¿å­˜è§„åˆ™ï¼‰
        let imageStats = { min: 0, max: 0, p1: 0, p99: 0 }; // å›¾åƒç»Ÿè®¡ä¿¡æ¯

        // ç”»å¸ƒç›¸å…³å˜é‡
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        let scale = 1;                 // ç¼©æ”¾æ¯”ä¾‹
        let offsetX = 0;               // å¹³ç§»Xåç§»
        let offsetY = 0;               // å¹³ç§»Yåç§»
        let isDragging = false;        // æ˜¯å¦æ­£åœ¨æ‹–åŠ¨
        let lastX, lastY;              // ä¸Šä¸€æ¬¡é¼ æ ‡ä½ç½®
        let imageBitmap = null;        // ç”¨äºç»˜åˆ¶çš„åŸå§‹å›¾åƒ

        // åŸæœ‰åƒç´ é€‰ä¸­/å¯¼èˆªå˜é‡
        let isPixelSelected = false;   // æ˜¯å¦ç‚¹å‡»é€‰ä¸­äº†åƒç´ 
        let keyboardNavMode = false;   // æ˜¯å¦å¼€å¯é”®ç›˜å¯¼èˆªæ¨¡å¼
        let selectedX = -1;            // é€‰ä¸­çš„åƒç´ Xåæ ‡
        let selectedY = -1;            // é€‰ä¸­çš„åƒç´ Yåæ ‡

        // ã€æ–°å¢ï¼šåç‚¹æ ‡è®°æ ¸å¿ƒå˜é‡ã€‘å®Œå…¨éµå¾ªåŸåç‚¹æ£€æµ‹å·¥å…·è§„åˆ™
        let autoBadPoints = new Set(); // è‡ªåŠ¨æ£€æµ‹åç‚¹ Set<"y,x">
        let manualBadPoints = new Set();// æ‰‹åŠ¨æ ‡è®°åç‚¹ Set<"y,x">
        let isMarkingMode = false;     // æ˜¯å¦å¤„äºåç‚¹æ ‡è®°æ¨¡å¼
        let currentMarkX = 0;          // æ ‡è®°æ¨¡å¼åå­—å‡†æ˜ŸX
        let currentMarkY = 0;          // æ ‡è®°æ¨¡å¼åå­—å‡†æ˜ŸY
        let threshold = 20;            // åç‚¹æ£€æµ‹ç°åº¦å·®é˜ˆå€¼

        // ã€DOMå…ƒç´ ã€‘åŸæœ‰å…ƒç´  + æ–°å¢åç‚¹ç›¸å…³å…ƒç´ 
        const fileInput = document.getElementById('fileInput');
        const fileName = document.getElementById('fileName');
        const widthInput = document.getElementById('widthInput');
        const heightInput = document.getElementById('heightInput');
        const rowMajorOrderCheckbox = document.getElementById('rowMajorOrder');
        const littleEndianCheckbox = document.getElementById('littleEndian');
        const noImageHint = document.getElementById('noImageHint');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const currentXEl = document.getElementById('currentX');
        const currentYEl = document.getElementById('currentY');
        const currentValueEl = document.getElementById('currentValue');
        const debugPanel = document.getElementById('debugPanel');
        const viewModeIndicator = document.getElementById('viewModeIndicator');
        const keyboardNavHint = document.getElementById('keyboardNavHint');
        const pixelSelectHint = document.getElementById('pixelSelectHint');
        const size640512 = document.getElementById('size640512');
        const size384288 = document.getElementById('size384288');
        const size12801024 = document.getElementById('size12801024');
        // æ–°å¢åç‚¹ç›¸å…³DOM
        const markModeIndicator = document.getElementById('markModeIndicator');
        const detectButton = document.getElementById('detectButton');
        const startMarkingButton = document.getElementById('startMarkingButton');
        const clearManualButton = document.getElementById('clearManualButton');
        const saveBadMaskButton = document.getElementById('saveBadMaskButton');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValue = document.getElementById('thresholdValue');
        const neighborhoodSelect = document.getElementById('neighborhoodSelect');
        const thresholdMinus = document.getElementById('thresholdMinus');
        const thresholdPlus = document.getElementById('thresholdPlus');
        const autoBadCount = document.getElementById('autoBadCount');
        const manualBadCount = document.getElementById('manualBadCount');
        const totalBadCount = document.getElementById('totalBadCount');
        const badPercentage = document.getElementById('badPercentage');
        const badPointListPanel = document.getElementById('badPointListPanel');

        // åˆå§‹åŒ–
        function init() {
            resizeCanvas();
            setupEventListeners();
            // åˆå§‹éšè—æ‰€æœ‰æ¨¡å¼æç¤º
            viewModeIndicator.classList.add('hidden');
            markModeIndicator.classList.add('hidden');
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨ï¼šåŸæœ‰äº‹ä»¶ + æ–°å¢åç‚¹ç›¸å…³äº‹ä»¶
        function setupEventListeners() {
            // åŸæœ‰äº‹ä»¶
            window.addEventListener('resize', resizeCanvas);
            rowMajorOrderCheckbox.addEventListener('change', (e) => {
                rowMajorOrder = e.target.checked;
                if (originalData) reloadImageData();
            });
            // æ–°å¢ï¼šå­—èŠ‚åºåˆ‡æ¢äº‹ä»¶
            littleEndianCheckbox.addEventListener('change', (e) => {
                littleEndian = e.target.checked;
            });
            size640512.addEventListener('click', () => { setImageSize(640, 512, size640512) });
            size384288.addEventListener('click', () => { setImageSize(384, 288, size384288) });
            size12801024.addEventListener('click', () => { setImageSize(1280, 1024, size12801024) });
            fileInput.addEventListener('change', handleFileSelect);
            setupCanvasEvents();
            window.addEventListener('keydown', handleKeyDown);

            // æ–°å¢ï¼šåç‚¹æ£€æµ‹å‚æ•°äº‹ä»¶
            thresholdSlider.addEventListener('input', (e) => {
                threshold = parseInt(e.target.value);
                thresholdValue.textContent = threshold;
            });
            // æ–°å¢ï¼šé˜ˆå€¼Â±1æŒ‰é’®ç‚¹å‡»äº‹ä»¶ï¼ˆå¸¦1-50è¾¹ç•Œé™åˆ¶ + åŒå‘è”åŠ¨ï¼‰
            thresholdMinus.addEventListener('click', () => {
                if (threshold > 1) { // ä¸èƒ½å°äºæœ€å°å€¼1
                    threshold--;
                    thresholdSlider.value = threshold; // åŒæ­¥æ»‘å—ä½ç½®
                    thresholdValue.textContent = threshold; // åŒæ­¥æ˜¾ç¤ºå€¼
                }
            });
            thresholdPlus.addEventListener('click', () => {
                if (threshold < 50) { // ä¸èƒ½å¤§äºæœ€å¤§å€¼50
                    threshold++;
                    thresholdSlider.value = threshold; // åŒæ­¥æ»‘å—ä½ç½®
                    thresholdValue.textContent = threshold; // åŒæ­¥æ˜¾ç¤ºå€¼
                }
            });
            // æ–°å¢ï¼šåç‚¹æ“ä½œæŒ‰é’®äº‹ä»¶
            detectButton.addEventListener('click', detectBadPoints);
            startMarkingButton.addEventListener('click', toggleMarkingMode);
            clearManualButton.addEventListener('click', clearManualMarkings);
            saveBadMaskButton.addEventListener('click', saveBadMask);
        }

        // åŸæœ‰åˆ†è¾¨ç‡è®¾ç½®å‡½æ•°
        function setImageSize(w, h, activeBtn) {
            widthInput.value = w;
            heightInput.value = h;
            width = w;
            height = h;
            [size640512, size384288, size12801024].forEach(btn => {
                btn.className = 'btn-short flex-1';
            });
            activeBtn.className = 'btn-short flex-1 btn-short-active';
            if (originalData) reloadImageData();
        }

        // åŸæœ‰ç”»å¸ƒå¤§å°è°ƒæ•´
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if (imageBitmap) drawCanvas();
        }

        // ç”»å¸ƒäº‹ä»¶ï¼šåŸæœ‰ + é€‚é…æ ‡è®°æ¨¡å¼
        function setupCanvasEvents() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleMouseWheel);
            canvas.addEventListener('mouseleave', () => {
                if (!isPixelSelected && !keyboardNavMode && !isMarkingMode) {
                    currentXEl.textContent = '-';
                    currentYEl.textContent = '-';
                    currentValueEl.textContent = '-';
                }
            });
        }

        // ã€æ ¸å¿ƒæ”¹é€ ã€‘é”®ç›˜äº‹ä»¶ï¼šå…¼å®¹åŸæœ‰å¯¼èˆª + æ–°å¢æ ‡è®°æ¨¡å¼å¿«æ·é”®
        function handleKeyDown(e) {
            if (!imageData) return;

            // æ ‡è®°æ¨¡å¼ä¼˜å…ˆçº§æœ€é«˜ï¼šå±è”½åŸæœ‰å¯¼èˆª/é€‰ä¸­äº‹ä»¶
            if (isMarkingMode) {
                handleMarkModeKeyDown(e);
                return;
            }

            // åŸæœ‰é”®ç›˜å¯¼èˆªé€»è¾‘
            if(e.key === ' ' && isPixelSelected && !keyboardNavMode) {
                e.preventDefault();
                keyboardNavMode = true;
                keyboardNavHint.classList.remove('hidden');
                pixelSelectHint.classList.add('hidden');
                drawCanvas();
                return;
            }
            if(e.key === 'Escape' && keyboardNavMode) {
                e.preventDefault();
                keyboardNavMode = false;
                keyboardNavHint.classList.add('hidden');
                pixelSelectHint.classList.remove('hidden');
                drawCanvas();
                return;
            }
            if (keyboardNavMode && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
                e.preventDefault();
                switch (e.key) {
                    case 'ArrowUp': selectedY = Math.max(0, selectedY - 1); break;
                    case 'ArrowDown': selectedY = Math.min(height - 1, selectedY + 1); break;
                    case 'ArrowLeft': selectedX = Math.max(0, selectedX - 1); break;
                    case 'ArrowRight': selectedX = Math.min(width - 1, selectedX + 1); break;
                }
                updateSelectedPixelInfo();
                drawCanvas();
            }
        }

        // æ–°å¢ï¼šæ ‡è®°æ¨¡å¼é”®ç›˜äº‹ä»¶ï¼ˆå®Œå…¨éµå¾ªåŸåç‚¹å·¥å…·è§„åˆ™ï¼Œé˜»æ­¢é»˜è®¤è¡Œä¸ºï¼‰
        function handleMarkModeKeyDown(e) {
            let moved = false;
            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    if (currentMarkY > 0) { currentMarkY--; moved = true; }
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (currentMarkY < height - 1) { currentMarkY++; moved = true; }
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (currentMarkX > 0) { currentMarkX--; moved = true; }
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (currentMarkX < width - 1) { currentMarkX++; moved = true; }
                    break;
                case ' ':
                    e.preventDefault(); // ç©ºæ ¼æ ‡è®°/å–æ¶ˆ
                    const point = `${currentMarkY},${currentMarkX}`;
                    manualBadPoints.has(point) ? manualBadPoints.delete(point) : manualBadPoints.add(point);
                    updateBadCount();
                    updateBadPointList();
                    drawCanvas();
                    break;
                case 'Enter':
                    e.preventDefault(); // å›è½¦é€€å‡ºæ ‡è®°æ¨¡å¼
                    toggleMarkingMode();
                    break;
            }
            if (moved) {
                updateMarkPositionInfo();
                drawCanvas();
            }
        }

        // åŸæœ‰é€‰ä¸­åƒç´ ä¿¡æ¯æ›´æ–°
        function updateSelectedPixelInfo() {
            if (selectedX < 0 || selectedY < 0 || !imageData) return;
            const index = rowMajorOrder ? (selectedY * width + selectedX) : (selectedX * height + selectedY);
            const grayValue = imageData[index];
            currentXEl.textContent = selectedX;
            currentYEl.textContent = selectedY;
            currentValueEl.textContent = grayValue;
        }

        // æ–°å¢ï¼šæ ‡è®°æ¨¡å¼å‡†æ˜Ÿä½ç½®ä¿¡æ¯æ›´æ–°
        function updateMarkPositionInfo() {
            if (!imageData) return;
            const index = rowMajorOrder ? (currentMarkY * width + currentMarkX) : (currentMarkX * height + currentMarkY);
            const grayValue = imageData[index];
            currentXEl.textContent = currentMarkX;
            currentYEl.textContent = currentMarkY;
            currentValueEl.textContent = grayValue;
        }

        // ã€æ ¸å¿ƒæ”¹é€ ã€‘ç”»å¸ƒç»˜åˆ¶ï¼šåŸæœ‰ç»˜åˆ¶ + åç‚¹/åå­—å‡†æ˜Ÿç»˜åˆ¶ï¼ˆä¸åŸåç‚¹å·¥å…·å¯è§†åŒ–ä¸€è‡´ï¼‰
        function drawCanvas() {
            if (!imageBitmap) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(imageBitmap, 0, 0);

            // 1. ç»˜åˆ¶è‡ªåŠ¨åç‚¹ï¼šçº¢è‰²åŠé€æ˜å°åœ†ï¼ˆä¸åŸå·¥å…·ä¸€è‡´ï¼‰
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
            autoBadPoints.forEach(point => {
                const [y, x] = point.split(',').map(Number);
                ctx.beginPath();
                ctx.arc(x + 0.5, y + 0.5, 2 / scale, 0, Math.PI * 2);
                ctx.fill();
            });

            // 2. ç»˜åˆ¶æ‰‹åŠ¨åç‚¹ï¼šçº¯è“è‰²å°åœ†ï¼ˆä¸åŸå·¥å…·ä¸€è‡´ï¼‰
            ctx.fillStyle = 'rgba(0, 204, 255, 1)';
            manualBadPoints.forEach(point => {
                const [y, x] = point.split(',').map(Number);
                ctx.beginPath();
                ctx.arc(x + 0.5, y + 0.5, 2 / scale, 0, Math.PI * 2);
                ctx.fill();
            });

            // 3. ç»˜åˆ¶æ ‡è®°æ¨¡å¼åå­—å‡†æ˜Ÿï¼šç»¿è‰²åå­—ï¼ˆä¸åŸå·¥å…·ä¸€è‡´ï¼‰
            if (isMarkingMode) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 1)';
                ctx.lineWidth = 1 / scale;
                // æ°´å¹³çº¿
                ctx.beginPath();
                ctx.moveTo(currentMarkX - 3 / scale + 0.5, currentMarkY + 0.5);
                ctx.lineTo(currentMarkX + 3 / scale + 0.5, currentMarkY + 0.5);
                ctx.stroke();
                // å‚ç›´çº¿
                ctx.beginPath();
                ctx.moveTo(currentMarkX + 0.5, currentMarkY - 3 / scale + 0.5);
                ctx.lineTo(currentMarkX + 0.5, currentMarkY + 3 / scale + 0.5);
                ctx.stroke();
            }

            ctx.restore();
            // åŸæœ‰åƒç´ é€‰ä¸­é«˜äº®
            drawPixelHighlight();
        }

        // åŸæœ‰åƒç´ é«˜äº®ç»˜åˆ¶ï¼ˆä¿®æ”¹ï¼šäº®è“è‰²è¾¹æ¡†+åŠ ç²—å®½åº¦ï¼Œæ›´é†’ç›®ï¼‰
        function drawPixelHighlight() {
            if (selectedX < 0 || selectedY < 0 || !imageData || isMarkingMode) return;
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            // æ›¿æ¢ä¸ºæ›´äº®çš„è“è‰²ï¼ˆ#0099FFï¼‰ï¼Œæ©™è‰²å¯¼èˆªè‰²ä¸å˜
            ctx.strokeStyle = keyboardNavMode ? '#FF7D00' : '#0099FF';
            // è¾¹æ¡†å®½åº¦ä»0.5è°ƒä¸º1ï¼Œç¼©æ”¾åæ›´ç²—ï¼Œè§†è§‰æ›´é†’ç›®
            ctx.lineWidth = 1 / scale;
            ctx.strokeRect(selectedX, selectedY, 1, 1);
            ctx.restore();
        }

        // ã€æ ¸å¿ƒæ–°å¢ã€‘åç‚¹è‡ªåŠ¨æ£€æµ‹ï¼šé€‚é…Y8 8bitç°åº¦ï¼ˆä»…æ”¹æ•°æ®ç±»å‹ï¼Œé€»è¾‘ä¸åŸå·¥å…·å®Œå…¨ä¸€è‡´ï¼‰
        function detectBadPoints() {
            if (!imageData) return;
            showLoading();
            detectButton.disabled = true;
            try {
                const neighborhoodSize = parseInt(neighborhoodSelect.value);
                const halfNeighborhood = Math.floor(neighborhoodSize / 2);
                const badPoints = new Set();

                // éå†æ‰€æœ‰åƒç´ ï¼ˆY8ä¸ºUint8Arrayï¼Œç›´æ¥å–ç°åº¦å€¼ï¼‰
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const centerIndex = rowMajorOrder ? (y * width + x) : (x * height + y);
                        const centerValue = imageData[centerIndex]; // 8bitç°åº¦å€¼
                        let aboveThresholdCount = 0;
                        let validNeighbors = 0;

                        // éå†é‚»åŸŸ
                        for (let ny = -halfNeighborhood; ny <= halfNeighborhood; ny++) {
                            for (let nx = -halfNeighborhood; nx <= halfNeighborhood; nx++) {
                                if (nx === 0 && ny === 0) continue;
                                const neighborX = x + nx;
                                const neighborY = y + ny;
                                if (neighborX >= 0 && neighborX < width && neighborY >= 0 && neighborY < height) {
                                    const neighborIndex = rowMajorOrder ? (neighborY * width + neighborX) : (neighborX * height + neighborY);
                                    const neighborValue = imageData[neighborIndex];
                                    if (Math.abs(centerValue - neighborValue) > threshold) {
                                        aboveThresholdCount++;
                                    }
                                    validNeighbors++;
                                }
                            }
                        }

                        // åˆ¤å®šåç‚¹ï¼šè¶…é˜ˆå€¼æ•°ï¼æœ‰æ•ˆé‚»åŸŸæ•°çš„1/2
                        if (validNeighbors > 0 && aboveThresholdCount > validNeighbors / 2) {
                            badPoints.add(`${y},${x}`);
                        }
                    }
                }

                autoBadPoints = badPoints;
                updateBadCount();
                updateBadPointList();
                drawCanvas();
            } catch (error) {
                console.error('æ£€æµ‹åç‚¹å¤±è´¥:', error);
                alert('æ£€æµ‹åç‚¹å¤±è´¥: ' + error.message);
            } finally {
                detectButton.disabled = false;
                hideLoading();
            }
        }

        // ã€æ ¸å¿ƒæ–°å¢ã€‘æ ‡è®°æ¨¡å¼åˆ‡æ¢ï¼šä¸åŸå·¥å…·äº¤äº’ä¸€è‡´ï¼ŒUIè”åŠ¨
        function toggleMarkingMode() {
            if (!imageData) return;
            if (isMarkingMode) {
                // é€€å‡ºæ ‡è®°æ¨¡å¼
                isMarkingMode = false;
                startMarkingButton.innerHTML = '<i class="fa fa-mouse-pointer"></i> å¼€å§‹æ‰‹åŠ¨æ ‡è®°';
                startMarkingButton.className = 'btn-secondary w-full';
                markModeIndicator.classList.add('hidden');
                viewModeIndicator.classList.remove('hidden');
                canvas.style.cursor = 'grab';
                // æ¢å¤åƒç´ ä¿¡æ¯é»˜è®¤æ˜¾ç¤º
                if (!isPixelSelected) {
                    currentXEl.textContent = '-';
                    currentYEl.textContent = '-';
                    currentValueEl.textContent = '-';
                } else {
                    updateSelectedPixelInfo();
                }
            } else {
                // è¿›å…¥æ ‡è®°æ¨¡å¼ï¼šå±è”½åŸæœ‰é€‰ä¸­/å¯¼èˆª
                isMarkingMode = true;
                keyboardNavMode = false;
                isPixelSelected = false;
                keyboardNavHint.classList.add('hidden');
                pixelSelectHint.classList.add('hidden');
                startMarkingButton.innerHTML = '<i class="fa fa-stop"></i> é€€å‡ºæ‰‹åŠ¨æ ‡è®°';
                startMarkingButton.className = 'btn-primary w-full';
                markModeIndicator.classList.remove('hidden');
                viewModeIndicator.classList.add('hidden');
                // å‡†æ˜Ÿé»˜è®¤å±…ä¸­
                currentMarkX = Math.floor(width / 2);
                currentMarkY = Math.floor(height / 2);
                updateMarkPositionInfo();
                canvas.style.cursor = 'crosshair';
            }
            drawCanvas();
        }

        // æ–°å¢ï¼šæ¸…é™¤æ‰‹åŠ¨æ ‡è®°ï¼ˆå¸¦ç¡®è®¤å¼¹çª—ï¼‰
        function clearManualMarkings() {
            if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰æ‰‹åŠ¨æ ‡è®°çš„åç‚¹å—ï¼Ÿ')) {
                manualBadPoints.clear();
                updateBadCount();
                updateBadPointList();
                drawCanvas();
            }
        }

        // ã€æ ¸å¿ƒæ–°å¢ã€‘ä¿å­˜16bitåç‚¹æ©ç ï¼šä¸åŸå·¥å…·æ ¼å¼å®Œå…¨ä¸€è‡´ï¼ˆåç‚¹0x1000ï¼Œæ­£å¸¸0ï¼Œ16bitäºŒè¿›åˆ¶ï¼‰
        function saveBadMask() {
            if (!imageData) return;
            showLoading();
            try {
                const totalPixels = width * height;
                const totalBytes = totalPixels * 2; // 16bit=2å­—èŠ‚/åƒç´ 
                const badFlagData = new Uint16Array(totalPixels); // 16bitæ— ç¬¦å·æ•´å‹
                const allBadPoints = new Set([...autoBadPoints, ...manualBadPoints]);

                // èµ‹å€¼ï¼šåç‚¹=0x1000ï¼Œæ­£å¸¸=0
                allBadPoints.forEach(point => {
                    const [y, x] = point.split(',').map(Number);
                    const index = rowMajorOrder ? (y * width + x) : (x * height + y);
                    badFlagData[index] = 0x1000;
                });

                // è½¬æ¢å­—èŠ‚åºï¼ˆå¤§/å°ç«¯ï¼‰ï¼Œç”ŸæˆUint8Array
                const byteData = new Uint8Array(totalBytes);
                for (let i = 0; i < totalPixels; i++) {
                    const byteOffset = i * 2;
                    const value = badFlagData[i];
                    if (littleEndian) {
                        byteData[byteOffset] = value & 0xFF; // ä½å­—èŠ‚åœ¨å‰
                        byteData[byteOffset + 1] = (value >> 8) & 0xFF; // é«˜å­—èŠ‚åœ¨å
                    } else {
                        byteData[byteOffset] = (value >> 8) & 0xFF; // é«˜å­—èŠ‚åœ¨å‰ï¼ˆé»˜è®¤ï¼‰
                        byteData[byteOffset + 1] = value & 0xFF; // ä½å­—èŠ‚åœ¨å
                    }
                }

                // ç”ŸæˆäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä¿å­˜ä¸º åŸæ–‡ä»¶å_bad.bin
                const blob = new Blob([byteData.buffer], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                let downloadName = 'y8_bad_points.bin';
                if (fileInput.files[0]) {
                    downloadName = fileInput.files[0].name.replace(/\.[^/.]+$/, "") + "_bad.bin";
                }
                a.href = url;
                a.download = downloadName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                alert('16bitåç‚¹æ©ç ä¿å­˜æˆåŠŸï¼');
            } catch (error) {
                console.error('ä¿å­˜åç‚¹æ©ç å¤±è´¥:', error);
                alert('ä¿å­˜å¤±è´¥: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        // æ–°å¢ï¼šæ›´æ–°åç‚¹ç»Ÿè®¡ï¼ˆè‡ªåŠ¨/æ‰‹åŠ¨/æ€»è®¡/å æ¯”ï¼‰
        function updateBadCount() {
            const autoCount = autoBadPoints.size;
            const manualCount = manualBadPoints.size;
            const totalCount = autoCount + manualCount;
            const totalPixels = width * height;
            const percentage = totalPixels > 0 ? (totalCount / totalPixels * 100).toFixed(6) : '0.0000';

            autoBadCount.textContent = autoCount;
            manualBadCount.textContent = manualCount;
            totalBadCount.textContent = totalCount;
            badPercentage.textContent = percentage;
        }

        // æ–°å¢ï¼šæ›´æ–°åç‚¹åˆ—è¡¨ï¼ˆç‚¹å‡»åæ ‡è·³è½¬æ”¾å¤§ï¼Œä¸åŸå·¥å…·ä¸€è‡´ï¼‰
        function updateBadPointList() {
            // è‡ªåŠ¨åç‚¹ï¼šçº¢è‰²ï¼Œæ‰‹åŠ¨åç‚¹ï¼šè“è‰²ï¼ŒæŒ‰åæ ‡æ’åº
            const autoList = Array.from(autoBadPoints)
                .sort((a, b) => {
                    const [ya, xa] = a.split(',').map(Number);
                    const [yb, xb] = b.split(',').map(Number);
                    return ya - yb || xa - xb;
                })
                .map(point => {
                    const [y, x] = point.split(',').map(Number);
                    return `<div class="cursor-pointer hover:bg-white/10 py-0.5" onclick="centerOnPoint(${x},${y})"><span class="text-red-400">(${x}, ${y})</span> <span class="text-red-300 text-xs">è‡ªåŠ¨</span></div>`;
                });

            const manualList = Array.from(manualBadPoints)
                .sort((a, b) => {
                    const [ya, xa] = a.split(',').map(Number);
                    const [yb, xb] = b.split(',').map(Number);
                    return ya - yb || xa - xb;
                })
                .map(point => {
                    const [y, x] = point.split(',').map(Number);
                    return `<div class="cursor-pointer hover:bg-white/10 py-0.5" onclick="centerOnPoint(${x},${y})"><span class="text-blue-400">(${x}, ${y})</span> <span class="text-blue-300 text-xs">æ‰‹åŠ¨</span></div>`;
                });

            const allPoints = [...autoList, ...manualList];

            if (allPoints.length === 0) {
                badPointListPanel.innerHTML = `
                    <p class="font-medium mb-1 text-green-400">ğŸ“Œ åç‚¹åˆ—è¡¨ï¼š</p>
                    <p class="text-gray-300">æš‚æ— åç‚¹æ•°æ®ï¼Œè¯·åŠ è½½å›¾åƒå¹¶æ£€æµ‹/æ ‡è®°</p>
                `;
            } else {
                badPointListPanel.innerHTML = `
                    <p class="font-medium mb-1 text-green-400">ğŸ“Œ åç‚¹åˆ—è¡¨ï¼ˆå…± ${allPoints.length} ä¸ªï¼Œç‚¹å‡»åæ ‡å¯è·³è½¬æ”¾å¤§ï¼‰ï¼š</p>
                    <div class="flex flex-col gap-1 mt-1">${allPoints.join('')}</div>
                `;
            }
        }

        // æ–°å¢ï¼šç‚¹å‡»åç‚¹åæ ‡è·³è½¬å¹¶æ”¾å¤§8å€
        function centerOnPoint(x, y) {
            scale = 8;
            offsetX = canvas.width / 2 - (x + 0.5) * scale;
            offsetY = canvas.height / 2 - (y + 0.5) * scale;
            drawCanvas();
        }

        // åŸæœ‰é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ï¼šé€‚é…æ ‡è®°æ¨¡å¼
        function handleMouseDown(e) {
            if (!imageData) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const imgX = Math.floor((mouseX - offsetX) / scale);
            const imgY = Math.floor((mouseY - offsetY) / scale);

            // æ ‡è®°æ¨¡å¼ï¼šç‚¹å‡»å®šä½å‡†æ˜Ÿ + å…è®¸æ‹–æ‹½
            if (isMarkingMode) {
                if (imgX >= 0 && imgX < width && imgY >= 0 && imgY < height) {
                    currentMarkX = imgX;
                    currentMarkY = imgY;
                    updateMarkPositionInfo();
                    drawCanvas();
                }
                isDragging = true;
                lastX = mouseX;
                lastY = mouseY;
                canvas.style.cursor = 'grabbing';
                return;
            }

            // åŸæœ‰éæ ‡è®°æ¨¡å¼é€»è¾‘
            if (keyboardNavMode) {
                if (imgX >= 0 && imgX < width && imgY >= 0 && imgY < height) {
                    isPixelSelected = true;
                    selectedX = imgX;
                    selectedY = imgY;
                    updateSelectedPixelInfo();
                    drawCanvas();
                }
                isDragging = true;
                lastX = mouseX;
                lastY = mouseY;
                canvas.style.cursor = 'grabbing';
                return;
            }

            if (imgX >= 0 && imgX < width && imgY >= 0 && imgY < height) {
                isPixelSelected = true;
                selectedX = imgX;
                selectedY = imgY;
                pixelSelectHint.classList.remove('hidden');
                updateSelectedPixelInfo();
                drawCanvas();
            } else {
                isDragging = true;
                lastX = mouseX;
                lastY = mouseY;
                canvas.style.cursor = 'grabbing';
            }
            if(e.button === 0) {
                isDragging = true;
                lastX = mouseX;
                lastY = mouseY;
            }
        }

        // åŸæœ‰é¼ æ ‡ç§»åŠ¨äº‹ä»¶ï¼šé€‚é…æ ‡è®°æ¨¡å¼
        function handleMouseMove(e) {
            if (!imageData) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (isDragging) {
                const dx = mouseX - lastX;
                const dy = mouseY - lastY;
                offsetX += dx;
                offsetY += dy;
                lastX = mouseX;
                lastY = mouseY;
                drawCanvas();
                return;
            }

            // æ ‡è®°æ¨¡å¼ï¼šé¼ æ ‡æ‚¬æµ®ä¸æ›´æ–°åƒç´ ä¿¡æ¯ï¼Œä»…å‡†æ˜Ÿæ§åˆ¶
            if (isMarkingMode) {
                canvas.style.cursor = 'crosshair';
                return;
            }

            // åŸæœ‰éæ ‡è®°æ¨¡å¼é€»è¾‘
            if (!isPixelSelected && !keyboardNavMode) {
                const x = Math.floor((mouseX - offsetX) / scale);
                const y = Math.floor((mouseY - offsetY) / scale);
                if (x >= 0 && x < width && y >= 0 && y < height) {
                    const index = rowMajorOrder ? (y * width + x) : (x * height + y);
                    currentXEl.textContent = x;
                    currentYEl.textContent = y;
                    currentValueEl.textContent = imageData[index];
                } else {
                    currentXEl.textContent = '-';
                    currentYEl.textContent = '-';
                    currentValueEl.textContent = '-';
                }
            }
            canvas.style.cursor = isPixelSelected ? 'default' : 'grab';
        }

        // åŸæœ‰é¼ æ ‡æ¾å¼€äº‹ä»¶
        function handleMouseUp() {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = isMarkingMode ? 'crosshair' : (isPixelSelected ? 'default' : 'grab');
            }
        }

        // åŸæœ‰é¼ æ ‡æ»šè½®ç¼©æ”¾
        function handleMouseWheel(e) {
            if (!imageData) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const imgX = (mouseX - offsetX) / scale;
            const imgY = (mouseY - offsetY) / scale;
            const zoomIntensity = 0.1;
            scale = e.deltaY < 0 ? scale * (1 + zoomIntensity) : scale / (1 + zoomIntensity);
            scale = Math.min(Math.max(0.1, scale), 10);
            offsetX = mouseX - imgX * scale;
            offsetY = mouseY - imgY * scale;
            drawCanvas();
        }

        // åŸæœ‰é‡æ–°åŠ è½½å›¾åƒ
        function reloadImageData() {
            if (!originalData) return;
            showLoading();
            try {
                const totalPixels = width * height;
                const byteView = new Uint8Array(originalData);
                if (byteView.length < totalPixels) {
                    throw new Error(`æ•°æ®ä¸è¶³ï¼šéœ€è¦ ${totalPixels} å­—èŠ‚ï¼Œæ–‡ä»¶ä»…${byteView.length}å­—èŠ‚`);
                }
                imageData = new Uint8Array(totalPixels);
                for (let i = 0; i < totalPixels; i++) {
                    imageData[i] = byteView[i];
                }
                calculateImageStats();
                createOriginalImageBitmap();
                resetView();
                // é‡ç½®åç‚¹
                autoBadPoints.clear();
                manualBadPoints.clear();
                updateBadCount();
                updateBadPointList();
                hideLoading();
            } catch (error) {
                console.error('é‡æ–°åŠ è½½å›¾åƒå¤±è´¥:', error);
                hideLoading();
            }
        }

        // åŸæœ‰æ–‡ä»¶é€‰æ‹©å¤„ç†
        async function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            showLoading();
            fileName.textContent = file.name;
            viewModeIndicator.classList.add('hidden');
            try {
                const arrayBuffer = await readFileAsync(file);
                originalData = arrayBuffer;
                width = parseInt(widthInput.value);
                height = parseInt(heightInput.value);
                const totalPixels = width * height;
                const byteView = new Uint8Array(originalData);
                if (byteView.length < totalPixels) {
                    throw new Error(`Y8æ–‡ä»¶æ•°æ®ä¸è¶³ï¼å®½Ã—é«˜=${width}Ã—${height}=${totalPixels}åƒç´ ï¼Œæ–‡ä»¶ä»…${byteView.length}å­—èŠ‚`);
                }
                imageData = new Uint8Array(totalPixels);
                for (let i = 0; i < totalPixels; i++) {
                    imageData[i] = byteView[i];
                }
                calculateImageStats();
                createOriginalImageBitmap();
                resetView();
                noImageHint.classList.add('hidden');
                viewModeIndicator.classList.remove('hidden');
                // å¯ç”¨åç‚¹æ“ä½œæŒ‰é’®
                detectButton.disabled = false;
                startMarkingButton.disabled = false;
                clearManualButton.disabled = false;
                saveBadMaskButton.disabled = false;
                // é‡ç½®åç‚¹
                autoBadPoints.clear();
                manualBadPoints.clear();
                updateBadCount();
                updateBadPointList();
            } catch (error) {
                console.error('åŠ è½½Y8æ–‡ä»¶å¤±è´¥:', error);
                alert('åŠ è½½æ–‡ä»¶å¤±è´¥: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        // åŸæœ‰å›¾åƒç»Ÿè®¡è®¡ç®—
        function calculateImageStats() {
            if (!imageData) return;
            const sortedValues = new Uint8Array(imageData);
            sortedValues.sort();
            const minValue = sortedValues[0];
            const maxValue = sortedValues[sortedValues.length - 1];
            const p1 = sortedValues[Math.floor(sortedValues.length * 0.01)];
            const p99 = sortedValues[Math.floor(sortedValues.length * 0.99)];
            imageStats = { min: minValue, max: maxValue, p1: p1, p99: p99 };
            debugPanel.innerHTML = `
                <p class="font-medium mb-1">å›¾åƒç»Ÿè®¡ (${width}Ã—${height} | Y8åŸå§‹8bitç°åº¦):</p>
                <p>åŸå§‹ç°åº¦æœ€å°å€¼: ${minValue}, æœ€å¤§å€¼: ${maxValue}</p>
                <p>1%åˆ†ä½ç°åº¦: ${p1}, 99%åˆ†ä½ç°åº¦: ${p99}</p>
                <p class="text-xs text-gray-400">åŸå§‹ç°åº¦æ ‡å‡†ï¼š0=çº¯é»‘ / 255=çº¯ç™½</p>
            `;
        }

        // åŸæœ‰Y8å›¾åƒè½¬ImageBitmap
        function createOriginalImageBitmap() {
            if (!imageData) return;
            const rgbaData = new Uint8ClampedArray(width * height * 4);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = rowMajorOrder ? (y * width + x) : (x * height + y);
                    const grayValue = imageData[index];
                    const rgbaIndex = (y * width + x) * 4;
                    rgbaData[rgbaIndex] = grayValue;
                    rgbaData[rgbaIndex + 1] = grayValue;
                    rgbaData[rgbaIndex + 2] = grayValue;
                    rgbaData[rgbaIndex + 3] = 255;
                }
            }
            const imageDataObj = new ImageData(rgbaData, width, height);
            createImageBitmap(imageDataObj).then(bitmap => {
                imageBitmap = bitmap;
                drawCanvas();
            });
        }

        // åŸæœ‰è§†å›¾é‡ç½®
        function resetView() {
            const scaleX = canvas.width / width;
            const scaleY = canvas.height / height;
            scale = Math.min(scaleX, scaleY);
            offsetX = (canvas.width - width * scale) / 2;
            offsetY = (canvas.height - height * scale) / 2;
            drawCanvas();
        }

        // åŸæœ‰å·¥å…·å‡½æ•°
        function showLoading() { loadingIndicator.classList.remove('hidden'); }
        function hideLoading() { loadingIndicator.classList.add('hidden'); }
        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsArrayBuffer(file);
            });
        }

        init();
    </script>
</body>
</html>
