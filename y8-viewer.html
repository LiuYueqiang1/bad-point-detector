<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原始Y8图像读取工具 (精准像素查看)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#36CFC9',
                        accent: '#FF7D00',
                        dark: '#1D2129',
                        light: '#F2F3F5'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .canvas-container {
                @apply relative border border-gray-300 rounded-lg overflow-hidden bg-gray-100;
            }
            .control-panel {
                @apply bg-white p-4 rounded-lg shadow-md;
            }
            .btn-primary {
                @apply bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded transition-all duration-200 flex items-center justify-center gap-2;
            }
            .btn-secondary {
                @apply bg-white border border-gray-300 hover:bg-gray-100 px-4 py-2 rounded transition-all duration-200 flex items-center justify-center gap-2;
            }
            .btn-short {
                @apply bg-gray-50 border border-gray-300 hover:bg-gray-200 px-2 py-1 rounded text-sm transition-all;
            }
            .btn-short-active {
                @apply bg-primary text-white border-primary hover:bg-primary/90 !important;
            }
            .status-bar {
                @apply bg-light p-2 rounded text-sm border border-gray-200;
            }
            .debug-panel {
                @apply bg-dark text-white p-3 rounded-lg text-sm font-mono overflow-auto max-h-40;
            }
            .nav-hint {
                @apply bg-accent/90 text-white px-3 py-1 rounded text-sm absolute top-2 right-2;
            }
            .select-hint {
                @apply bg-blue-600/90 text-white px-3 py-1 rounded text-sm absolute top-2 right-24;
            }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div class="container mx-auto px-4 py-6 max-w-7xl">
        <header class="mb-6">
            <h1 class="text-[clamp(1.5rem,3vw,2.5rem)] font-bold text-dark flex items-center gap-3">
                <i class="fa fa-file-image-o text-primary"></i>
                原始Y8图像读取工具 (精准像素查看)
            </h1>
            <p class="text-gray-500 mt-1">8bit灰度原始显示 · 像素级精准查看 · 1280×1024/640×512/384×288三分辨率兼容</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <div class="lg:col-span-1 space-y-4">
                <div class="control-panel">
                    <h2 class="text-lg font-semibold mb-3 text-dark border-b pb-2">文件操作</h2>
                    <div class="space-y-3">
                        <label class="btn-primary w-full cursor-pointer">
                            <i class="fa fa-file-image-o"></i> 加载Y8图像文件
                            <input type="file" id="fileInput" accept=".raw,.bin,.dat,.y8" class="hidden">
                        </label>
                        <div id="fileInfo" class="text-sm text-gray-500">
                            <p id="fileName" class="truncate">未选择文件</p>
                            <div class="grid grid-cols-2 gap-2 mt-2">
                                <div>
                                    <label class="block text-xs text-gray-500">宽度</label>
                                    <input type="number" id="widthInput" class="w-full text-sm border rounded px-2 py-1" value="640">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-500">高度</label>
                                    <input type="number" id="heightInput" class="w-full text-sm border rounded px-2 py-1" value="512">
                                </div>
                            </div>
                            <div class="flex gap-2 mt-2">
                                <button id="size640512" class="btn-short flex-1 btn-short-active">640×512</button>
                                <button id="size384288" class="btn-short flex-1">384×288</button>
                                <button id="size12801024" class="btn-short flex-1">1280×1024</button>
                            </div>
                            <div class="space-y-2 mt-3">
                                <div class="flex items-center gap-2 p-2 bg-gray-50 rounded border border-gray-200">
                                    <input type="checkbox" id="rowMajorOrder" checked>
                                    <label for="rowMajorOrder" class="text-sm">行优先存储</label>
                                </div>
                                <div class="flex items-center gap-2 p-2 bg-gray-50 rounded border border-gray-200 text-gray-400">
                                    <i class="fa fa-info-circle"></i>
                                    <label class="text-sm">Y8格式：单字节无大小端，0=黑/255=白</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-3 space-y-4">
                <div class="canvas-container" style="height: 600px;">
                    <canvas id="imageCanvas" class="w-full h-full"></canvas>
                    <div id="loadingIndicator" class="absolute inset-0 bg-black/50 flex items-center justify-center hidden">
                        <div class="bg-white p-4 rounded-lg flex items-center gap-3">
                            <i class="fa fa-circle-o-notch fa-spin text-primary text-xl"></i>
                            <span>加载原始图像中...</span>
                        </div>
                    </div>
                    <div id="noImageHint" class="absolute inset-0 flex flex-col items-center justify-center text-gray-400">
                        <i class="fa fa-picture-o text-5xl mb-3"></i>
                        <p>请加载Y8格式原始图像文件</p>
                    </div>
                    <div class="absolute top-2 left-2 bg-black/70 text-white px-3 py-1 rounded text-sm" id="viewModeIndicator">
                        原始模式：滚轮缩放+左键拖动 | 点击像素选中 → 空格开启键盘导航 | ESC退出
                    </div>
                    <div class="nav-hint hidden" id="keyboardNavHint">
                        <i class="fa fa-keyboard-o"></i> 键盘导航中：↑↓←→移动像素 | ESC退出
                    </div>
                    <div class="select-hint hidden" id="pixelSelectHint">
                        <i class="fa fa-check-circle"></i> 已选中像素 | 按空格开启键盘导航
                    </div>
                </div>

                <div class="status-bar">
                    <p><span class="font-medium">当前像素信息:</span> X: <span id="currentX">-</span>, Y: <span id="currentY">-</span>, 原始灰度值: <span id="currentValue">-</span> (0~255)</p>
                </div>

                <div class="debug-panel" id="debugPanel">
                    <p class="font-medium mb-1">图像统计 (等待加载):</p>
                    <p>分辨率: - × - | 最小灰度: -, 最大灰度: -, 1%分位: -, 99%分位: -</p>
                </div>
            </div>
        </div>

        <footer class="mt-8 text-center text-gray-500 text-sm py-4 border-t">
            <p>原始Y8图像读取工具 &copy; 2026 | 精准像素查看优化版</p>
        </footer>
    </div>

    <script>
        // 全局变量 - 纯原始Y8读取，无任何调光参数
        let imageData = null;          // 原始图像数据（8位 Uint8Array）
        let originalData = null;       // 原始字节数据
        let width = 640;               // 默认分辨率 640*512
        let height = 512;              // 默认分辨率
        let rowMajorOrder = true;      // 是否行优先存储
        let imageStats = { min: 0, max: 0, p1: 0, p99: 0 }; // 图像统计信息

        // 画布相关变量
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        let scale = 1;                 // 缩放比例
        let offsetX = 0;               // 平移X偏移
        let offsetY = 0;               // 平移Y偏移
        let isDragging = false;        // 是否正在拖动
        let lastX, lastY;              // 上一次鼠标位置
        let imageBitmap = null;        // 用于绘制的原始图像

        // 核心修改：新增选中状态、分离选中/导航模式
        let isPixelSelected = false;   // 是否点击选中了像素
        let keyboardNavMode = false;   // 是否开启键盘导航模式
        let selectedX = -1;            // 选中的像素X坐标
        let selectedY = -1;            // 选中的像素Y坐标

        // DOM元素
        const fileInput = document.getElementById('fileInput');
        const fileName = document.getElementById('fileName');
        const fileInfo = document.getElementById('fileInfo');
        const widthInput = document.getElementById('widthInput');
        const heightInput = document.getElementById('heightInput');
        const rowMajorOrderCheckbox = document.getElementById('rowMajorOrder');
        const noImageHint = document.getElementById('noImageHint');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const currentXEl = document.getElementById('currentX');
        const currentYEl = document.getElementById('currentY');
        const currentValueEl = document.getElementById('currentValue');
        const debugPanel = document.getElementById('debugPanel');
        const viewModeIndicator = document.getElementById('viewModeIndicator');
        const keyboardNavHint = document.getElementById('keyboardNavHint');
        const pixelSelectHint = document.getElementById('pixelSelectHint');
        const size640512 = document.getElementById('size640512');
        const size384288 = document.getElementById('size384288');
        const size12801024 = document.getElementById('size12801024');

        // 初始化
        function init() {
            resizeCanvas();
            setupEventListeners();
            viewModeIndicator.classList.add('hidden');
        }

        // 设置事件监听器
        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);
            rowMajorOrderCheckbox.addEventListener('change', (e) => {
                rowMajorOrder = e.target.checked;
                if (originalData) reloadImageData();
            });
            size640512.addEventListener('click', () => { setImageSize(640, 512, size640512) });
            size384288.addEventListener('click', () => { setImageSize(384, 288, size384288) });
            size12801024.addEventListener('click', () => { setImageSize(1280, 1024, size12801024) });

            fileInput.addEventListener('change', handleFileSelect);
            setupCanvasEvents();
            window.addEventListener('keydown', handleKeyDown);
        }

        function setImageSize(w, h, activeBtn) {
            widthInput.value = w;
            heightInput.value = h;
            width = w;
            height = h;
            [size640512, size384288, size12801024].forEach(btn => {
                btn.className = 'btn-short flex-1';
            });
            activeBtn.className = 'btn-short flex-1 btn-short-active';
            if (originalData) reloadImageData();
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if (imageBitmap) drawCanvas();
        }

        function setupCanvasEvents() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleMouseWheel);
            canvas.addEventListener('mouseleave', () => {
                if (!isPixelSelected && !keyboardNavMode) {
                    currentXEl.textContent = '-';
                    currentYEl.textContent = '-';
                    currentValueEl.textContent = '-';
                }
            });
        }

        function handleKeyDown(e) {
            if (!imageData) return;
            if(e.key === ' ' && isPixelSelected && !keyboardNavMode) {
                e.preventDefault();
                keyboardNavMode = true;
                keyboardNavHint.classList.remove('hidden');
                pixelSelectHint.classList.add('hidden');
                drawCanvas();
                return;
            }
            if(e.key === 'Escape' && keyboardNavMode) {
                e.preventDefault();
                keyboardNavMode = false;
                keyboardNavHint.classList.add('hidden');
                pixelSelectHint.classList.remove('hidden');
                drawCanvas();
                return;
            }
            if (keyboardNavMode && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
                e.preventDefault();
                switch (e.key) {
                    case 'ArrowUp': selectedY = Math.max(0, selectedY - 1); break;
                    case 'ArrowDown': selectedY = Math.min(height - 1, selectedY + 1); break;
                    case 'ArrowLeft': selectedX = Math.max(0, selectedX - 1); break;
                    case 'ArrowRight': selectedX = Math.min(width - 1, selectedX + 1); break;
                }
                updateSelectedPixelInfo();
                drawCanvas();
            }
        }

        function updateSelectedPixelInfo() {
            if (selectedX < 0 || selectedY < 0 || !imageData) return;
            const index = rowMajorOrder ? (selectedY * width + selectedX) : (selectedX * height + selectedY);
            const grayValue = imageData[index];
            currentXEl.textContent = selectedX;
            currentYEl.textContent = selectedY;
            currentValueEl.textContent = grayValue;
        }

        function drawPixelHighlight() {
            if (selectedX < 0 || selectedY < 0 || !imageData) return;
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            ctx.strokeStyle = keyboardNavMode ? '#FF7D00' : '#165DFF';
            ctx.lineWidth = 0.5 / scale;
            ctx.strokeRect(selectedX, selectedY, 1, 1);
            ctx.restore();
        }

        function reloadImageData() {
            if (!originalData) return;
            showLoading();
            try {
                const totalPixels = width * height;
                const byteView = new Uint8Array(originalData);
                if (byteView.length < totalPixels) {
                    throw new Error(`数据不足：需要 ${totalPixels} 字节，文件仅${byteView.length}字节`);
                }
                imageData = new Uint8Array(totalPixels);
                for (let i = 0; i < totalPixels; i++) {
                    imageData[i] = byteView[i];
                }
                calculateImageStats();
                createOriginalImageBitmap();
                resetView();
                hideLoading();
            } catch (error) {
                console.error('重新加载图像失败:', error);
                hideLoading();
            }
        }

        async function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            showLoading();
            fileName.textContent = file.name;
            fileInfo.classList.remove('hidden');
            viewModeIndicator.classList.add('hidden');
            try {
                const arrayBuffer = await readFileAsync(file);
                originalData = arrayBuffer;
                width = parseInt(widthInput.value);
                height = parseInt(heightInput.value);
                const totalPixels = width * height;
                const byteView = new Uint8Array(originalData);
                if (byteView.length < totalPixels) {
                    throw new Error(`Y8文件数据不足！宽×高=${width}×${height}=${totalPixels}像素，文件仅${byteView.length}字节`);
                }
                imageData = new Uint8Array(totalPixels);
                for (let i = 0; i < totalPixels; i++) {
                    imageData[i] = byteView[i];
                }
                calculateImageStats();
                createOriginalImageBitmap();
                resetView();
                noImageHint.classList.add('hidden');
                viewModeIndicator.classList.remove('hidden');
            } catch (error) {
                console.error('加载Y8文件失败:', error);
                alert('加载文件失败: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        function calculateImageStats() {
            if (!imageData) return;
            const sortedValues = new Uint8Array(imageData);
            sortedValues.sort();
            const minValue = sortedValues[0];
            const maxValue = sortedValues[sortedValues.length - 1];
            const p1 = sortedValues[Math.floor(sortedValues.length * 0.01)];
            const p99 = sortedValues[Math.floor(sortedValues.length * 0.99)];
            imageStats = { min: minValue, max: maxValue, p1: p1, p99: p99 };
            debugPanel.innerHTML = `
                <p class="font-medium mb-1">图像统计 (${width}×${height} | Y8原始8bit灰度):</p>
                <p>原始灰度最小值: ${minValue}, 最大值: ${maxValue}</p>
                <p>1%分位灰度: ${p1}, 99%分位灰度: ${p99}</p>
                <p class="text-xs text-gray-400">原始灰度标准：0=纯黑 / 255=纯白</p>
            `;
        }

        function createOriginalImageBitmap() {
            if (!imageData) return;
            const rgbaData = new Uint8ClampedArray(width * height * 4);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = rowMajorOrder ? (y * width + x) : (x * height + y);
                    const grayValue = imageData[index];
                    const rgbaIndex = (y * width + x) * 4;
                    rgbaData[rgbaIndex] = grayValue;
                    rgbaData[rgbaIndex + 1] = grayValue;
                    rgbaData[rgbaIndex + 2] = grayValue;
                    rgbaData[rgbaIndex + 3] = 255;
                }
            }
            const imageDataObj = new ImageData(rgbaData, width, height);
            createImageBitmap(imageDataObj).then(bitmap => {
                imageBitmap = bitmap;
                drawCanvas();
            });
        }

        function drawCanvas() {
            if (!imageBitmap) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(imageBitmap, 0, 0);
            ctx.restore();
            drawPixelHighlight();
        }

        // ========== ✅ 核心BUG修复 开始 ==========
        function handleMouseDown(e) {
            if (!imageData) return;
            // 关键判断：如果处于【键盘导航模式】，只执行拖动逻辑，不执行任何像素选中逻辑
            if(keyboardNavMode) {
                isDragging = true;
                lastX = e.clientX - canvas.getBoundingClientRect().left;
                lastY = e.clientY - canvas.getBoundingClientRect().top;
                canvas.style.cursor = 'grabbing';
                return;
            }
            // 非导航模式，执行原有正常逻辑
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const imgX = Math.floor((mouseX - offsetX) / scale);
            const imgY = Math.floor((mouseY - offsetY) / scale);

            if (imgX >= 0 && imgX < width && imgY >= 0 && imgY < height) {
                isPixelSelected = true;
                selectedX = imgX;
                selectedY = imgY;
                pixelSelectHint.classList.remove('hidden');
                updateSelectedPixelInfo();
                drawCanvas();
            } else {
                isDragging = true;
                lastX = mouseX;
                lastY = mouseY;
                canvas.style.cursor = 'grabbing';
            }
            if(e.button === 0) {
                isDragging = true;
                lastX = mouseX;
                lastY = mouseY;
            }
        }
        // ========== ✅ 核心BUG修复 结束 ==========

        function handleMouseMove(e) {
            if (!imageData) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (isDragging) {
                const dx = mouseX - lastX;
                const dy = mouseY - lastY;
                offsetX += dx;
                offsetY += dy;
                lastX = mouseX;
                lastY = mouseY;
                drawCanvas();
                return;
            }

            if (!isPixelSelected && !keyboardNavMode) {
                const x = Math.floor((mouseX - offsetX) / scale);
                const y = Math.floor((mouseY - offsetY) / scale);
                if (x >= 0 && x < width && y >= 0 && y < height) {
                    const index = rowMajorOrder ? (y * width + x) : (x * height + y);
                    currentXEl.textContent = x;
                    currentYEl.textContent = y;
                    currentValueEl.textContent = imageData[index];
                } else {
                    currentXEl.textContent = '-';
                    currentYEl.textContent = '-';
                    currentValueEl.textContent = '-';
                }
            }
        }

        function handleMouseUp() {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = 'grab';
            }
        }

        function handleMouseWheel(e) {
            if (!imageData) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const imgX = (mouseX - offsetX) / scale;
            const imgY = (mouseY - offsetY) / scale;
            const zoomIntensity = 0.1;
            scale = e.deltaY < 0 ? scale * (1 + zoomIntensity) : scale / (1 + zoomIntensity);
scale = Math.min(Math.max(0.1, scale), 10);
            offsetX = mouseX - imgX * scale;
            offsetY = mouseY - imgY * scale;
            drawCanvas();
        }

        function resetView() {
            const scaleX = canvas.width / width;
            const scaleY = canvas.height / height;
            scale = Math.min(scaleX, scaleY);
            offsetX = (canvas.width - width * scale) / 2;
            offsetY = (canvas.height - height * scale) / 2;
            drawCanvas();
        }

        function showLoading() { loadingIndicator.classList.remove('hidden'); }
        function hideLoading() { loadingIndicator.classList.add('hidden'); }
        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsArrayBuffer(file);
            });
        }

        init();
    </script>
</body>
</html>
